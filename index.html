<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>fretboard</title>

  <style>
    :root {
      --fret-width: 90px;
      --string-gap: 54px;
      --double-marker-gap: 18px;
      --size-scale: 1;
      --primary-color: #6366f1;
      --primary-hover: #4f46e5;
      --primary-active: #4338ca;
      --grey-color: #6b7280;
      --grey-hover: #4b5563;
      --border-radius: 8px;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    }

    * {
      box-sizing: border-box;
    }

    #export-area {
      display: inline-block;
      background: #fff;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
    }

    #export-padding {
      padding: 40px;
      box-sizing: content-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 60px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #1f2937;
    }

    h1 {
      margin-bottom: 30px;
      font-size: 2.5rem;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Editable title styling */
    h1[contenteditable="true"] {
      padding: 8px 12px;
      border-radius: var(--border-radius);
      outline: none;
      cursor: text;
      transition: all 0.2s ease;
      display: inline-block;
    }

    h1[contenteditable="true"]:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    h1[contenteditable="true"]:focus {
      background: rgba(255, 255, 255, 0.95);
      color: #1f2937;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.3);
    }

    /* Manche */
    .fretboard {
      position: relative;
      display: grid;
      grid-template-columns: repeat(12, calc(var(--fret-width) * var(--size-scale)));
      grid-template-rows: repeat(6, calc(var(--string-gap) * var(--size-scale)));
      border-left: calc(6px * var(--size-scale)) solid #1f2937;
      background: linear-gradient(180deg, #f9fafb 0%, #f3f4f6 100%);
      border-radius: 4px;
    }

    /* Piano keyboard */
    .fretboard.piano {
      display: block;
      grid-template-columns: none;
      grid-template-rows: none;
      border-left: none !important;
      background: #1f2937;
      overflow-x: scroll;
      overflow-y: hidden;
      padding: 0;
      border-radius: 8px;
      height: auto;
      max-width: calc(840px * var(--size-scale));
    }
    
    /* Always show scrollbar for piano */
    .fretboard.piano::-webkit-scrollbar {
      height: 12px;
    }
    
    .fretboard.piano::-webkit-scrollbar-track {
      background: #e5e7eb;
      border-radius: 6px;
    }
    
    .fretboard.piano::-webkit-scrollbar-thumb {
      background: #9ca3af;
      border-radius: 6px;
    }
    
    .fretboard.piano::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }

    .piano-key {
      position: relative;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }

    .piano-key.white {
      width: calc(40px * var(--size-scale));
      height: calc(200px * var(--size-scale));
      background: white;
      border: calc(2px * var(--size-scale)) solid #1f2937;
      border-right: calc(1px * var(--size-scale)) solid #999;
      z-index: 1;
    }

    .piano-key.white:hover {
      background: #f0f0f0;
    }

    .piano-key.black {
      width: calc(28px * var(--size-scale));
      height: calc(120px * var(--size-scale));
      background: linear-gradient(180deg, #2d2d2d 0%, #000 100%);
      border: calc(1px * var(--size-scale)) solid #000;
      position: absolute;
      margin-left: calc(-14px * var(--size-scale));
      z-index: 2;
    }

    .piano-key.black:hover {
      background: linear-gradient(180deg, #3d3d3d 0%, #111 100%);
    }

    .piano-container {
      position: relative;
      display: inline-flex;
      min-width: min-content;
    }

    /* Case */
    .cell {
      position: relative;
      border-right: 1px solid #bbb; /* frettes */
    }

    /* Cordes */
    .cell::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      background: #555;
      transform: translateY(-50%);
    }

    /* RepÃ¨res de touche */
    .marker {
      position: absolute;
      width: calc(15px * var(--size-scale));
      height: calc(15px * var(--size-scale));
      background: #d0d0d0;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* Notes */
.note {
  position: absolute;
  width: calc(39px * var(--size-scale));
  height: calc(39px * var(--size-scale));
  border-radius: 50%;
  transform: translate(-50%, -50%);
  cursor: pointer;
  z-index: 12;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: calc(18px * var(--size-scale));
  font-weight: 600;
  transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.08));
  border: calc(3px * var(--size-scale)) solid rgba(255,255,255,0.12);
}


    /* Hover indicator (shadowy circle under mouse) */
    .hover-indicator {
      position: absolute;
      width: calc(33px * var(--size-scale));
      height: calc(33px * var(--size-scale));
      border-radius: 50%;
      background: rgba(27, 27, 27, 0.12);
      border: calc(3px * var(--size-scale)) solid rgba(38, 38, 38, 0.22);
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: left 0.06s linear, top 0.06s linear, opacity 0.12s;
      opacity: 0;
      z-index: 8;
      /*box-shadow: 0 5px 10px rgba(0,0,0,0.28);*/
    }

    .hover-indicator.visible {
      opacity: 1;
    }

    /* Note normale */
   .note.normal {
  background: linear-gradient(180deg, #7a6cff, #5a49e6);
  border-color: rgba(106,80,255,0.85);
}


    /* Fondamentale */
.note.root {
  background: linear-gradient(180deg, #111111, #000000);
  border: calc(1.5px * var(--size-scale)) solid  rgba(0,0,0,0.32);
  width: calc(39px * var(--size-scale));
  height: calc(39px * var(--size-scale));
  box-shadow: 0 8px 24px rgba(0,0,0,0.32), inset 0 2px 6px rgba(255,255,255,0.04);
}
    /* Grey notes */
.note.grey {
  background: linear-gradient(180deg, #cccccc, #aaaaaa);
  border-color: rgba(128,128,128,0.85);
}
    /* Selected note */
.note.selected {
  transform: translate(-50%, -50%) scale(1.12);
  box-shadow: 0 10px 30px rgba(30,130,255,0.28), 0 0 10px rgba(30,130,255,0.9);
  z-index: 20;
}
    /* Hover */
    .note:hover {
  transform: translate(-50%, -50%) scale(1.08);
  filter: brightness(1. 08);
}


    /* Zone corde Ã  vide */
    .open-string {
      position: absolute;
      left: calc(-22px * var(--size-scale));  /* centered around the open note position */
      width: calc(36px * var(--size-scale));
      height: calc(33px * var(--size-scale));
      transform: translateY(-50%);
      cursor: pointer;
      z-index: 5;
    }


.note.open {
  background: #fff;
  color: #111;
  border-width: calc(4.5px * var(--size-scale));
  border-style: solid;
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}

/* White disc for showing all note names */
.note.all-notes-display {
  background: #fff;
  color: #111;
  border: calc(2px * var(--size-scale)) solid #ddd;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  font-weight: 600;
  pointer-events: auto;
  cursor: pointer;
}

/* Open string follows note type color */
.note.open.normal {
  background: #fff;
  color: #111;
  border-color: #6b5cff;
}

.note.open.root {
  background: #fff;
  color: #111;
  border-color: #111;
}
/* Ensure grey open strings keep white background with grey border */
.note.open.grey {
  background: #fff;
  color: #111;
  border-color: rgba(128,128,128,0.85);
}
/* Keep selected open note white but with selected visual */
.note.open.selected {
  background: #fff;
  color: #111;
}

    /* Button styling */
    button {
      padding: 12px 24px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      margin-right: 10px;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-md);
      font-family: inherit;
    }

    button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    button:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    #export-svg {
      background: var(--primary-color);
    }

    #export-svg:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    #export-svg:active {
      background: var(--primary-active);
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    /* Fill buttons grid */
    .fill-buttons {
      display: flex;
      gap: 8px;
      width: fit-content;
      margin-left: 20px;
      margin-right: 20px;
    }

    .fill-buttons button {
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
    }

    .fill-buttons button.grey-btn {
      background: var(--grey-color);
      color: white;
    }

    .fill-buttons button.grey-btn:hover {
      background: var(--grey-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Make open-string notes show the selected shadow when selected */
    .note.open.selected {
      transform: translate(-50%, -50%) scale(1.12);
      box-shadow: 0 10px 30px rgba(30,130,255,0.28), 0 0 10px rgba(30,130,255,0.9);
      z-index: 20;
    }

    /* Give the Fill selected button the same highlight shadow */
    #fill-selected-toggle {
      box-shadow: 0 10px 30px rgba(30,130,255,0.12), 0 0 8px rgba(30,130,255,0.5);
    }
    #fill-selected-toggle:hover {
      box-shadow: 0 12px 36px rgba(30,130,255,0.22), 0 0 12px rgba(30,130,255,0.85);
      transform: translateY(-1px);
    }

    /* Color palette */
    .color-palette {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-left: 12px;
      padding: 8px 12px;
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-md);
    }
    
    .color-palette-swatches {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    /* Floating color palette */
    #floating-color-palette {
      position: fixed;
      display: none;
      gap: 10px;
      padding: 12px;
      background: white;
      border-radius: var(--border-radius);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 1000;
      pointer-events: auto;
    }
    
    #floating-color-palette.visible {
      display: flex;
    }
    
    /* Help section */
    .help-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--primary-color);
      color: white;
      border: none;
      font-size: 22px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: var(--shadow-lg);
      transition: all 0.3s ease;
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .help-button:hover {
      background: var(--primary-hover);
      transform: scale(1.1);
      box-shadow: 0 8px 24px rgba(99,102,241,0.3);
    }
    
    .help-panel {
      position: fixed;
      bottom: 75px;
      right: 20px;
      width: 420px;
      max-height: 70vh;
      background: white;
      border-radius: var(--border-radius);
      box-shadow: 0 12px 40px rgba(0,0,0,0.2);
      padding: 20px 24px;
      display: none;
      z-index: 998;
      overflow-y: auto;
    }
    
    .help-panel.visible {
      display: block;
      animation: slideUp 0.3s ease;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .help-panel h3 {
      margin: 0 0 16px 0;
      color: var(--primary-color);
      font-size: 18px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 8px;
    }
    
    .help-section {
      margin-bottom: 16px;
    }
    
    .help-section h4 {
      margin: 0 0 8px 0;
      color: #1f2937;
      font-size: 14px;
      font-weight: 600;
    }
    
    .help-section ul {
      margin: 0;
      padding-left: 20px;
      list-style: none;
    }
    
    .help-section li {
      margin-bottom: 6px;
      color: #4b5563;
      font-size: 13px;
      line-height: 1.5;
      position: relative;
    }
    
    .help-section li:before {
      content: "â€¢";
      position: absolute;
      left: -12px;
      color: var(--primary-color);
      font-weight: bold;
    }
    
    .help-section kbd {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      border: 1px solid #d1d5db;
      color: #374151;
      font-weight: 600;
    }
    
    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 3px solid white;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: all 0.2s ease;
    }
    .color-swatch:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    }
    .color-swatch.selected {
      border-color: #1f2937;
      transform: scale(1.15);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3), 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    /* Note color classes */
    .note.color-1 { background: linear-gradient(180deg,#7a6cff,#5a49e6); border-color: rgba(106,80,255,0.85); }
    .note.color-2 { background: linear-gradient(180deg,#ff6b6b,#e04444); border-color: rgba(220,60,60,0.9); }
    .note.color-3 { background: linear-gradient(180deg,#6bff9e,#2fc86d); border-color: rgba(40,180,100,0.9); }
    .note.color-4 { background: linear-gradient(180deg,#ffd36b,#ffb84d); border-color: rgba(220,150,40,0.9); }
    .note.color-5 { background: linear-gradient(180deg,#6bc8ff,#3da8ff); border-color: rgba(60,150,220,0.9); }
    .note.color-6 { background: linear-gradient(180deg,#111111,#000000); border-color: rgba(0,0,0,0.9); }

    /* Open-string color variants: keep white background but use the color's border */
    .note.open.color-1 { background: #fff; color: #111; border-color: rgba(106,80,255,0.85); }
    .note.open.color-2 { background: #fff; color: #111; border-color: rgba(220,60,60,0.9); }
    .note.open.color-3 { background: #fff; color: #111; border-color: rgba(40,180,100,0.9); }
    .note.open.color-4 { background: #fff; color: #111; border-color: rgba(220,150,40,0.9); }
    .note.open.color-5 { background: #fff; color: #111; border-color: rgba(60,150,220,0.9); }
    .note.open.color-6 { background: #fff; color: #111; border-color: rgba(0,0,0,0.9); }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      body {
        padding: 20px 10px;
        overflow-x: hidden;
      }

      h1 {
        font-size: 1.8rem;
        margin-bottom: 20px;
      }

      #export-area {
        overflow-x: auto;
        overflow-y: visible;
        max-width: 100%;
        display: block;
      }

      #export-padding {
        padding: 20px;
        width: fit-content;
        min-width: max-content;
      }

      .fretboard {
        /* Keep natural size, don't shrink */
        min-width: max-content;
      }

      /* Make controls stack vertically on mobile */
      .controls-container {
        flex-direction: column !important;
        align-items: stretch !important;
      }

      .controls-container > div {
        width: 100% !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        margin-bottom: 12px;
      }

      /* Button adjustments for touch */
      button {
        padding: 14px 20px;
        font-size: 16px;
        min-height: 44px;
        margin-bottom: 8px;
      }

      .fill-buttons {
        flex-direction: column;
        margin-left: 0;
        margin-right: 0;
        width: 100%;
      }

      .fill-buttons button {
        width: 100%;
        margin-right: 0;
      }

      /* Color palette adjustments */
      .color-palette {
        margin-left: 0;
        width: 100%;
      }

      .color-palette-swatches {
        justify-content: space-around;
      }

      .color-swatch {
        width: 40px;
        height: 40px;
      }

      /* Input adjustments */
      input[type="number"],
      input[type="text"] {
        font-size: 16px !important;
        min-height: 44px;
      }

      input[type="range"] {
        width: 100% !important;
      }

      /* Checkbox and radio adjustments */
      input[type="checkbox"],
      input[type="radio"] {
        width: 20px !important;
        height: 20px !important;
      }

      /* Instructions box */
      .instructions-box {
        font-size: 14px;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 10px 5px;
        overflow-x: hidden;
      }

      h1 {
        font-size: 1.5rem;
      }

      #export-area {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      #export-padding {
        padding: 10px;
      }

      .color-swatch {
        width: 36px;
        height: 36px;
      }

      button {
        font-size: 15px;
      }
    }

  </style>
</head>
<body>

<div id="export-area">
  <div id="export-padding">
    <div class="fretboard" id="fretboard"></div>
  </div>
</div>

<!-- Floating color palette -->
<div id="floating-color-palette">
  <div class="color-swatch" data-color="color-1" style="background: linear-gradient(180deg,#7a6cff,#5a49e6)"></div>
  <div class="color-swatch" data-color="color-2" style="background: linear-gradient(180deg,#ff6b6b,#e04444)"></div>
  <div class="color-swatch" data-color="color-3" style="background: linear-gradient(180deg,#6bff9e,#2fc86d)"></div>
  <div class="color-swatch" data-color="color-4" style="background: linear-gradient(180deg,#ffd36b,#ffb84d)"></div>
  <div class="color-swatch" data-color="color-5" style="background: linear-gradient(180deg,#6bc8ff,#3da8ff)"></div>
  <div class="color-swatch" data-color="color-6" style="background: linear-gradient(180deg,#111111,#000000)"></div>
</div>


<div style="margin-top: 30px; background: white; padding: 24px; border-radius: var(--border-radius); box-shadow: var(--shadow-lg);">
  <div class="controls-container" style="display: flex; align-items: flex-start; gap: 24px; flex-wrap: wrap;">
    <!-- First Row: Instrument and Basic Controls -->
    <div style="display: flex; flex-direction: column; gap: 12px; min-width: 100%;">
      <div style="display: flex; align-items: center; gap: 24px; flex-wrap: wrap;">
        <button id="clear">Clear</button>
        <div style="display: flex; align-items: center; gap: 12px; padding: 8px 16px; background: #f9fafb; border-radius: var(--border-radius);">
          <label for="instrument-select" style="font-weight: 600; color: #374151;">Instrument:</label>
          <select id="instrument-select" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 15px; font-weight: 600; font-family: inherit; cursor: pointer; background: white;">
            <option value="guitar">Guitar (6 strings)</option>
            <option value="ukulele">Ukulele (4 strings)</option>
            <option value="bass">Bass (4 strings)</option>
            <option value="piano">Piano (keyboard)</option>
          </select>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="keep-notes" />
          <label for="keep-notes" style="font-weight: 500; color: #374151; cursor: pointer;">Keep notes when changing instrument (be careful of instruments ranges if you want to come back to the current one)</label>
        </div>
        <div style="display: flex; align-items: center; gap: 16px; padding: 8px 16px; background: #f9fafb; border-radius: var(--border-radius);">
          <label for="left-end" style="font-weight: 600; color: #374151;">Left end:</label>
          <input type="number" id="left-end" min="0" max="12" value="0" style="width: 70px; padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 15px; font-weight: 600; text-align: center; font-family: inherit;">
          <label for="right-end" style="font-weight: 600; color: #374151;">Right end:</label>
          <input type="number" id="right-end" min="0" max="12" value="12" style="width: 70px; padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 15px; font-weight: 600; text-align: center; font-family: inherit;">
        </div>
      </div>
    </div>

    <!-- Second Row: Display Chord and Display Scale side by side -->
    <div style="display: flex; gap: 24px; flex-wrap: wrap; width: 100%;">
      <!-- Display Chord -->
      <div style="flex: 1; min-width: 400px; display: flex; flex-direction: column; gap: 12px; padding: 12px 16px; background: #f9fafb; border-radius: var(--border-radius); box-shadow: var(--shadow-sm);">
        <label style="font-weight: 600; color: #374151; font-size: 16px;">Display Chord:</label>
        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="chord-root" style="font-weight: 500; color: #374151;">Root:</label>
            <select id="chord-root" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 14px; font-weight: 600; font-family: inherit; cursor: pointer; background: white; width: 100px;">
              <option value="0">C</option>
              <option value="1">C#/Db</option>
              <option value="2">D</option>
              <option value="3">D#/Eb</option>
              <option value="4">E</option>
              <option value="5">F</option>
              <option value="6">F#/Gb</option>
              <option value="7">G</option>
              <option value="8">G#/Ab</option>
              <option value="9">A</option>
              <option value="10">A#/Bb</option>
              <option value="11">B</option>
            </select>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="chord-type" style="font-weight: 500; color: #374151;">Type:</label>
            <select id="chord-type" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 14px; font-weight: 600; font-family: inherit; cursor: pointer; background: white; width: 150px;">
              <option value="M">Major (M)</option>
              <option value="m">Minor (m)</option>
              <option value="Maj7">Maj7 / â–³</option>
              <option value="m7">m7</option>
              <option value="7">7</option>
              <option value="m7b5">m7b5 / Ã¸</option>
              <option value="dim triad">dim triad / Â°</option>
              <option value="dim">dim / Â°7</option>
              <option value="m6">m6</option>
              <option value="6">6</option>
              <option value="7#11">7#11</option>
              <option value="Maj7#11">Maj7#11 / lydian</option>
            </select>
          </div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
          <button id="chord-clear-show" style="background: var(--primary-color); color: white; padding: 6px 12px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Clear and Show</button>
          <button id="chord-show-top" style="background: var(--primary-color); color: white; padding: 6px 12px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Show on Top</button>
        </div>
        <div style="display: flex; gap: 12px; align-items: center;">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151; font-size: 14px;">
            <input type="radio" name="chord-color-mode" id="chord-current-color" value="current" checked style="width: 16px; height: 16px; cursor: pointer;">
            Current color
          </label>
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151; font-size: 14px;">
            <input type="radio" name="chord-color-mode" id="chord-color-function" value="function" style="width: 16px; height: 16px; cursor: pointer;">
            Color by function
          </label>
        </div>
      </div>

      <!-- Display Scale -->
      <div style="flex: 1; min-width: 400px; display: flex; flex-direction: column; gap: 12px; padding: 12px 16px; background: #f9fafb; border-radius: var(--border-radius); box-shadow: var(--shadow-sm);">
        <label style="font-weight: 600; color: #374151; font-size: 16px;">Display Scale:</label>
        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="scale-root" style="font-weight: 500; color: #374151;">Root:</label>
            <select id="scale-root" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 14px; font-weight: 600; font-family: inherit; cursor: pointer; background: white; width: 180px;">
              <option value="0">C major / A minor</option>
              <option value="1">C#/Db major / A#/Bb minor</option>
              <option value="2">D major / B minor</option>
              <option value="3">D#/Eb major / C minor</option>
              <option value="4">E major / C#/Db minor</option>
              <option value="5">F major / D minor</option>
              <option value="6">F#/Gb major / D#/Eb minor</option>
              <option value="7">G major / E minor</option>
              <option value="8">G#/Ab major / F minor</option>
              <option value="9">A major / F#/Gb minor</option>
              <option value="10">A#/Bb major / G minor</option>
              <option value="11">B major / G#/Ab minor</option>
            </select>
          </div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
          <button id="scale-clear-show" style="background: var(--primary-color); color: white; padding: 6px 12px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Clear and Show</button>
          <button id="scale-show-top" style="background: var(--primary-color); color: white; padding: 6px 12px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Show on Top</button>
        </div>
        <div style="display: flex; gap: 12px; align-items: center;">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151; font-size: 14px;">
            <input type="radio" name="scale-color-mode" id="scale-current-color" value="current" checked style="width: 16px; height: 16px; cursor: pointer;">
            Current color
          </label>
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151; font-size: 14px;">
            <input type="radio" name="scale-color-mode" id="scale-color-function" value="function" style="width: 16px; height: 16px; cursor: pointer;">
            Color by function
          </label>
        </div>
      </div>
    </div>

    <!-- Third Row: Show Notes and other controls -->
    <div style="display: flex; flex-direction: column; gap: 8px; padding: 8px 12px; background: white; border-radius: var(--border-radius); box-shadow: var(--shadow-md);">
      <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 500; color: #374151;">
        <input type="checkbox" id="show-notes" style="width: 18px; height: 18px; cursor: pointer;">
        Note labels
      </label>
      <div style="display: flex; gap: 16px; margin-left: 26px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="display-mode" id="display-notes" value="notes" checked style="width: 16px; height: 16px; cursor: pointer;">
          Note name
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="display-mode" id="display-function" value="function" style="width: 16px; height: 16px; cursor: pointer;">
          Function (relative to the selected note)
        </label>
      </div>
      <div style="display: flex; gap: 16px; margin-left: 26px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="display-scope" id="display-selected" value="selected" checked style="width: 16px; height: 16px; cursor: pointer;">
          Filled only
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="display-scope" id="display-chord" value="chord" style="width: 16px; height: 16px; cursor: pointer;">
          Chord only
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="display-scope" id="display-all" value="all" style="width: 16px; height: 16px; cursor: pointer;">
          All
        </label>
      </div>
      <div style="display: flex; gap: 16px; margin-left: 26px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="note-system" id="use-letters" value="letters" checked style="width: 16px; height: 16px; cursor: pointer;">
          C, D, E...
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="note-system" id="use-solfege" value="solfege" style="width: 16px; height: 16px; cursor: pointer;">
          do, rÃ©, mi...
        </label>
      </div>
      <div style="display: flex; gap: 16px; margin-left: 26px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="note-notation" id="use-sharps" value="sharps" checked style="width: 16px; height: 16px; cursor: pointer;">
          Sharps (#)
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="note-notation" id="use-flats" value="flats" style="width: 16px; height: 16px; cursor: pointer;">
          Flats (â™­)
        </label>
      </div>
      <div style="display: flex; gap: 16px; margin-left: 26px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="tritone-notation" id="use-tritone-aug" value="augmented" checked style="width: 16px; height: 16px; cursor: pointer;">
          Tritone: 4+
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 500; color: #374151;">
          <input type="radio" name="tritone-notation" id="use-tritone-dim" value="diminished" style="width: 16px; height: 16px; cursor: pointer;">
          Tritone: 5-
        </label>
      </div>
    </div>

    <div class="color-palette" aria-label="Color palette">
      <label style="font-weight: 600; color: #374151;">Next note color (c):</label>
      <div class="color-palette-swatches">
        <div class="color-swatch selected" data-color="color-1" style="background: linear-gradient(180deg,#7a6cff,#5a49e6)"></div>
        <div class="color-swatch" data-color="color-2" style="background: linear-gradient(180deg,#ff6b6b,#e04444)"></div>
        <div class="color-swatch" data-color="color-3" style="background: linear-gradient(180deg,#6bff9e,#2fc86d)"></div>
        <div class="color-swatch" data-color="color-4" style="background: linear-gradient(180deg,#ffd36b,#ffb84d)"></div>
        <div class="color-swatch" data-color="color-5" style="background: linear-gradient(180deg,#6bc8ff,#3da8ff)"></div>
        <div class="color-swatch" data-color="color-6" style="background: linear-gradient(180deg,#111111,#000000)"></div>
      </div>
    </div>

    <div class="fill-buttons">
      <button id="fill-toggle">Fill / Unfill all (f)</button>
      <button id="fill-grey-toggle" class="grey-btn">Fill / Unfill grey (g)</button>
      <button id="fill-selected-toggle">Fill / Unfill selected (s)</button>
    </div>

    <div>
      <button id="save-diagram">Save diagram</button>
      <button id="load-diagram">Load diagram</button>
      <input type="file" id="load-file-input" accept=".json" style="display: none;">
      <button id="export-png">Export PNG</button>
      <button id="export-svg">Export SVG</button>
    </div>

    <div style="display: flex; align-items: center; gap: 12px;">
      <label style="font-weight: 600; color: #374151;">File name:</label>
      <input type="text" id="title" value="diagram" autocomplete="off" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 15px; font-weight: 600; font-family: inherit; min-width: 200px;">
    </div>
    <div style="display: flex; align-items: center; gap: 12px; padding: 8px 16px; background: #f9fafb; border-radius: var(--border-radius);">
      <label for="size-slider" style="font-weight: 600; color: #374151;">Size (+/-):</label>
      <input type="range" id="size-slider" min="0.8" max="1.3" step="0.05" value="1" style="width: 120px; cursor: pointer;">
      <span id="size-value" style="font-weight: 600; color: #374151; min-width: 40px;">1.0x</span>
    </div>
    <div style="display: flex; align-items: center; gap: 12px; padding: 8px 16px; background: #f9fafb; border-radius: var(--border-radius);">
      <label for="png-quality" style="font-weight: 600; color: #374151;">PNG export quality:</label>
      <select id="png-quality" style="padding: 8px 12px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 14px; font-weight: 600; font-family: inherit; cursor: pointer; background: white;">
        <option value="1">1x</option>
        <option value="2" selected>2x</option>
        <option value="3">3x</option>
        <option value="4">4x</option>
      </select>
    </div>
  </div>
</div>

<!-- Help button and panel -->
<button class="help-button" id="help-button" title="Help">?</button>
<div class="help-panel" id="help-panel">
  <h3>ðŸŽ¸ How to Use This Tool</h3>
  
  <div class="help-section">
    <h4>Basic Interactions</h4>
    <ul>
      <li><strong>Click</strong> on a cell to add or remove a note</li>
      <li><strong>Ctrl + Click</strong> (or <strong>long press</strong> on mobile) to select a note</li>
      <li><strong>Hold <kbd>d</kbd></strong> and hover over notes to delete them</li>
    </ul>
  </div>
  
  <div class="help-section">
    <h4>Keyboard Shortcuts</h4>
    <ul>
      <li><kbd>c</kbd> - Toggle floating color palette at mouse position</li>
      <li><kbd>f</kbd> - Fill/unfill all notes of the current color</li>
      <li><kbd>g</kbd> - Fill/unfill all grey notes</li>
      <li><kbd>s</kbd> - Fill/unfill all instances of the selected note</li>
      <li><kbd>+</kbd> / <kbd>-</kbd> - Increase/decrease diagram size</li>
    </ul>
  </div>
  
  <div class="help-section">
    <h4>Display Chord & Scale</h4>
    <ul>
      <li><strong>Clear and Show</strong> - Removes all notes and displays the selected chord/scale</li>
      <li><strong>Show on Top</strong> - Displays the chord/scale while keeping existing notes</li>
      <li><strong>Color by function</strong> - Colors notes based on their role (root, 3rd, 5th, etc.)</li>
    </ul>
  </div>
  
  <div class="help-section">
    <h4>Note Labels</h4>
    <ul>
      <li><strong>Note name</strong> - Shows the actual note (C, D, E...)</li>
      <li><strong>Function</strong> - Shows intervals relative to selected note (R, 3M, 5...)</li>
      <li><strong>Filled only / Chord only / All</strong> - Controls which notes show labels</li>
      <li>Choose between <strong>Sharps (#)</strong> or <strong>Flats (â™­)</strong></li>
      <li>Choose <strong>4+</strong> or <strong>5-</strong> for tritone intervals</li>
    </ul>
  </div>
  
  <div class="help-section">
    <h4>Fill/Unfill Options</h4>
    <ul>
      <li><kbd>f</kbd> - <strong>Fill/Unfill all</strong> - Fills all notes that are the same as the current ones with the chosen color</li>
      <li><kbd>g</kbd> - <strong>Fill/Unfill grey</strong> - Fills all notes that are the same as the current ones in grey</li>
      <li><kbd>s</kbd> - <strong>Fill/Unfill selected</strong> - If not all instances of the selected note are filled, it fills all of them with the chosen color. Otherwise, it unfills all of them</li>
    </ul>
  </div>
  
  <div class="help-section">
    <h4>Save/Load/Export</h4>
    <ul>
      <li><strong>Save</strong> - Saves your current diagram to browser storage (all the fretboard)</li>
      <li><strong>Load</strong> - Restores a previously saved diagram (all the fretboard)</li>
      <li><strong>Export PNG/SVG</strong> - Downloads your diagram as an image/SVG file (current window only)</li>
      <li><strong>File name</strong> - File name used for diagram export/save</li>
      <li><strong>PNG export quality</strong> - Choose export resolution: 1x, 2x, 3x, 4x</li>
    </ul>
  </div>
</div>

<script>
  const fretboard = document.getElementById("fretboard");

  // Track 'd' key state for delete mode
  window.deleteMode = false;
  
  document.addEventListener('keydown', (e) => {
    if (e.key === 'd' || e.key === 'D') {
      window.deleteMode = true;
      // Add visual feedback
      document.body.style.cursor = 'not-allowed';
    }
  });
  
  document.addEventListener('keyup', (e) => {
    if (e.key === 'd' || e.key === 'D') {
      window.deleteMode = false;
      // Remove visual feedback
      document.body.style.cursor = '';
    }
  });

  const MARKER_FRETS = [3, 5, 7, 9];
  const DOUBLE_MARKER_FRET = 12;

  // Instrument configurations
  const INSTRUMENTS = {
    guitar: {
      name: 'Guitar',
      type: 'fretboard',
      strings: 6,
      tuning: [5, 12, 8, 3, 10, 5], // E, B, G, D, A, E (string 0 = highest pitch)
      octaves: [5, 4, 4, 4, 3, 3] // E5, B4, G4, D4, A3, E3 (string 0 = highest)
    },
    ukulele: {
      name: 'Ukulele',
      type: 'fretboard',
      strings: 4,
      tuning: [10, 5, 1, 8], // A, E, C, G (string 0 = highest pitch)
      octaves: [4, 4, 4, 4] // A4, E4, C4, G4
    },
    bass: {
      name: 'Bass',
      type: 'fretboard',
      strings: 4,
      tuning: [8, 3, 10, 5], // G, D, A, E (string 0 = highest pitch)
      octaves: [3, 3, 2, 2] // G3, D3, A2, E2 (lowest open E on octave 2 for consistency with the guitar)
    },
    piano: {
      name: 'Piano',
      type: 'keyboard',
      keys: 88, // Full piano keyboard (A0 to C8)
      startNote: 10, // Start from A
      startOctave: 0 // Piano starts at A0, middle C (C4) is at key 39
    }
  };

  // Current instrument state
  window.currentInstrument = 'guitar';
  
  function getCurrentConfig() {
    return INSTRUMENTS[window.currentInstrument];
  }
  
  function getNote(string, fret) {
    const config = getCurrentConfig();
    if (config.type === 'keyboard') {
      // For piano: string represents key index, fret is always 0
      // Piano starts at A (note 10), convert to 0-based, then back to 1-based
      const noteIndex = ((config.startNote - 1 + string) % 12);
      return noteIndex + 1;
    }
    return ((config.tuning[string] + fret - 1) % 12) + 1;
  }
  
  // Calculate absolute pitch for a note position (includes octave)
  // Returns a unique number representing the exact pitch (MIDI note number style)
  function getAbsolutePitch(string, fret, config) {
    if (config.type === 'keyboard') {
      // For piano: calculate from start note and octave
      // Piano starts at A0 (MIDI 21), but we'll use simpler 0-based: A0 = 9
      const keyPosition = string; // string is actually key index for piano
      // Each key is one semitone: A0, A#0, B0, C1, C#1, etc.
      const totalSemitones = keyPosition;
      const noteValue = (config.startNote - 1 + totalSemitones) % 12; // 0-11
      const octave = config.startOctave + Math.floor((config.startNote - 1 + totalSemitones) / 12);
      return octave * 12 + noteValue;
    } else {
      // For fretboard: calculate from string tuning + octave + fret
      // tuning[string] is 1-12, convert to 0-11 for calculation
      const openStringNote = config.tuning[string] - 1; // Convert to 0-11
      const openStringOctave = config.octaves[string];
      const totalSemitones = openStringNote + fret;
      const octave = openStringOctave + Math.floor(totalSemitones / 12);
      const noteValue = totalSemitones % 12;
      return octave * 12 + noteValue;
    }
  }
  
  // Convert notes between instruments by preserving exact pitches (note + octave)
  function convertNotesToNewInstrument(oldInstrument, newInstrument) {
    const oldConfig = INSTRUMENTS[oldInstrument];
    const newConfig = INSTRUMENTS[newInstrument];
    
    if (!oldConfig || !newConfig) return;
    
    console.log('Converting from', oldInstrument, 'to', newInstrument);
    console.log('Current notes before conversion:', window.clickedNotes.length, 'clicked,', window.filledNotes.length, 'filled');
    
    // Collect all unique absolute pitches from current notes
    const pitchMap = new Map(); // absolutePitch -> {colors: Set, types: Set}
    
    // Process clicked notes
    window.clickedNotes.forEach(note => {
      const absolutePitch = getAbsolutePitch(note.string, note.fret, oldConfig);
      
      if (!pitchMap.has(absolutePitch)) {
        pitchMap.set(absolutePitch, {colors: new Set(), types: new Set()});
      }
      pitchMap.get(absolutePitch).colors.add(note.color);
      pitchMap.get(absolutePitch).types.add(note.type || 'normal');
    });
    
    // Process filled notes
    window.filledNotes.forEach(note => {
      const absolutePitch = getAbsolutePitch(note.string, note.fret, oldConfig);
      
      if (!pitchMap.has(absolutePitch)) {
        pitchMap.set(absolutePitch, {colors: new Set(), types: new Set()});
      }
      pitchMap.get(absolutePitch).colors.add(note.color);
      pitchMap.get(absolutePitch).types.add(note.type || 'normal');
    });
    
    // Process grey notes
    window.greyNotes.forEach(note => {
      const absolutePitch = getAbsolutePitch(note.string, note.fret, oldConfig);
      
      if (!pitchMap.has(absolutePitch)) {
        pitchMap.set(absolutePitch, {colors: new Set(), types: new Set()});
      }
      pitchMap.get(absolutePitch).colors.add('grey');
      pitchMap.get(absolutePitch).types.add(note.type || 'normal');
    });
    
    // Now find all positions on new instrument that match these absolute pitches
    const newClicked = [];
    const newFilled = [];
    const newGrey = [];
    
    if (newConfig.type === 'keyboard') {
      // Map to piano keys
      for (let key = 0; key < newConfig.keys; key++) {
        const absolutePitch = getAbsolutePitch(key, 0, newConfig);
        if (pitchMap.has(absolutePitch)) {
          const info = pitchMap.get(absolutePitch);
          info.colors.forEach(color => {
            const note = {string: key, fret: 0, type: Array.from(info.types)[0], color: color};
            if (color === 'grey') {
              // Avoid duplicates in grey notes
              if (!newGrey.some(n => n.string === key && n.fret === 0)) {
                newGrey.push(note);
              }
            } else {
              // Avoid duplicates - first color becomes clicked
              if (!newClicked.some(n => n.string === key && n.fret === 0) &&
                  !newFilled.some(n => n.string === key && n.fret === 0)) {
                newClicked.push(note);
              }
            }
          });
        }
      }
    } else {
      // Map to fretboard (strings and frets)
      for (let string = 0; string < newConfig.strings; string++) {
        for (let fret = 0; fret <= 12; fret++) {
          const absolutePitch = getAbsolutePitch(string, fret, newConfig);
          if (pitchMap.has(absolutePitch)) {
            const info = pitchMap.get(absolutePitch);
            info.colors.forEach(color => {
              const note = {string: string, fret: fret, type: Array.from(info.types)[0], color: color};
              if (color === 'grey') {
                // Avoid duplicates in grey notes
                if (!newGrey.some(n => n.string === string && n.fret === fret)) {
                  newGrey.push(note);
                }
              } else {
                // Avoid duplicates - first color becomes clicked
                if (!newClicked.some(n => n.string === string && n.fret === fret) &&
                    !newFilled.some(n => n.string === string && n.fret === fret)) {
                  newClicked.push(note);
                }
              }
            });
          }
        }
      }
    }
    
    // Update global note arrays
    window.clickedNotes = newClicked;
    window.filledNotes = newFilled;
    window.greyNotes = newGrey;
    
    // Convert lastChordNotes and lastScaleNotes to new instrument
    if (window.lastChordNotes.length > 0) {
      const chordPitches = new Set();
      window.lastChordNotes.forEach(note => {
        const absolutePitch = getAbsolutePitch(note.string, note.fret, oldConfig);
        chordPitches.add(absolutePitch);
      });
      
      const newChordNotes = [];
      if (newConfig.type === 'keyboard') {
        for (let key = 0; key < newConfig.keys; key++) {
          const absolutePitch = getAbsolutePitch(key, 0, newConfig);
          if (chordPitches.has(absolutePitch)) {
            newChordNotes.push({string: key, fret: 0});
          }
        }
      } else {
        for (let string = 0; string < newConfig.strings; string++) {
          for (let fret = 0; fret <= 12; fret++) {
            const absolutePitch = getAbsolutePitch(string, fret, newConfig);
            if (chordPitches.has(absolutePitch)) {
              newChordNotes.push({string: string, fret: fret});
            }
          }
        }
      }
      window.lastChordNotes = newChordNotes;
    }
    
    if (window.lastScaleNotes.length > 0) {
      const scalePitches = new Set();
      window.lastScaleNotes.forEach(note => {
        const absolutePitch = getAbsolutePitch(note.string, note.fret, oldConfig);
        scalePitches.add(absolutePitch);
      });
      
      const newScaleNotes = [];
      if (newConfig.type === 'keyboard') {
        for (let key = 0; key < newConfig.keys; key++) {
          const absolutePitch = getAbsolutePitch(key, 0, newConfig);
          if (scalePitches.has(absolutePitch)) {
            newScaleNotes.push({string: key, fret: 0});
          }
        }
      } else {
        for (let string = 0; string < newConfig.strings; string++) {
          for (let fret = 0; fret <= 12; fret++) {
            const absolutePitch = getAbsolutePitch(string, fret, newConfig);
            if (scalePitches.has(absolutePitch)) {
              newScaleNotes.push({string: string, fret: fret});
            }
          }
        }
      }
      window.lastScaleNotes = newScaleNotes;
    }
    
    console.log('After conversion:', newClicked.length, 'clicked,', newFilled.length, 'filled');
    console.log('Converted notes:', newClicked);
  }
  
  // Helper to check if a piano key is black
  function isPianoBlackKey(keyIndex) {
    const config = getCurrentConfig();
    // Calculate which note this key represents (0-11, where C=0)
    const noteValue = (config.startNote - 1 + keyIndex) % 12;
    // Black keys are C#(1), D#(3), F#(6), G#(8), A#(10) in 0-based where C=0
    return [1, 3, 6, 8, 10].includes(noteValue);
  }

  const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const NOTE_NAMES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
  const NOTE_NAMES_SOLFEGE = ['do', 'do#', 'rÃ©', 'rÃ©#', 'mi', 'fa', 'fa#', 'sol', 'sol#', 'la', 'la#', 'si'];
  const NOTE_NAMES_SOLFEGE_FLAT = ['do', 'rÃ©b', 'rÃ©', 'mib', 'mi', 'fa', 'solb', 'sol', 'lab', 'la', 'sib', 'si'];
  const INTERVAL_NAMES_AUGMENTED = ['R', '2m', '2M', '3m', '3M', '4', '4+', '5', '6m', '6M', '7m', '7M'];
  const INTERVAL_NAMES_DIMINISHED = ['R', '2m', '2M', '3m', '3M', '4', '5-', '5', '6m', '6M', '7m', '7M'];
  
  window.useSharps = true; // Default to sharps
  window.useSolfege = false; // Default to letter notation (C, D, E...)
  window.useTritoneAugmented = true; // Default to 4+ (instead of 5-)
  
  function getNoteName(noteNumber) {
    let names;
    if (window.useSolfege) {
      names = window.useSharps ? NOTE_NAMES_SOLFEGE : NOTE_NAMES_SOLFEGE_FLAT;
    } else {
      names = window.useSharps ? NOTE_NAMES : NOTE_NAMES_FLAT;
    }
    return names[(noteNumber - 1) % 12];
  }

  function getInterval(fromNote, toNote) {
    // Calculate interval: distance from fromNote to toNote
    const interval = ((toNote - fromNote) % 12 + 12) % 12;
    const intervalNames = window.useTritoneAugmented ? INTERVAL_NAMES_AUGMENTED : INTERVAL_NAMES_DIMINISHED;
    return intervalNames[interval];
  }

  // Chord definitions: intervals from root (in semitones)
  const CHORD_INTERVALS = {
    'M': [0, 4, 7],           // Major: Root, Major 3rd, Perfect 5th
    'm': [0, 3, 7],           // Minor: Root, Minor 3rd, Perfect 5th
    'Maj7': [0, 4, 7, 11],    // Major 7th: Root, Major 3rd, Perfect 5th, Major 7th
    'm7': [0, 3, 7, 10],      // Minor 7th: Root, Minor 3rd, Perfect 5th, Minor 7th
    '7': [0, 4, 7, 10],       // Dominant 7th: Root, Major 3rd, Perfect 5th, Minor 7th
    'm7b5': [0, 3, 6, 10],    // Half-diminished: Root, Minor 3rd, Diminished 5th, Minor 7th
    'dim triad': [0, 3, 6],   // Diminished triad: Root, Minor 3rd, Diminished 5th
    'dim': [0, 3, 6, 9],      // Diminished 7th: Root, Minor 3rd, Diminished 5th, Diminished 7th
    'm6': [0, 3, 7, 9],       // Minor 6th: Root, Minor 3rd, Perfect 5th, Major 6th
    '6': [0, 4, 7, 9],        // Major 6th: Root, Major 3rd, Perfect 5th, Major 6th
    '7#11': [0, 4, 6, 7, 10], // Dominant 7th #11: Root, Major 3rd, #11, Perfect 5th, Minor 7th
    'Maj7#11': [0, 4, 6, 7, 11] // Major 7th #11 (Lydian): Root, Major 3rd, #11, Perfect 5th, Major 7th
  };

  // Color scheme for chord functions
  const CHORD_FUNCTION_COLORS = {
    0: 'color-6',  // Root (black)
    3: 'color-2',  // Minor 3rd (red)
    4: 'color-2',  // Major 3rd (red)
    6: 'color-4',  // Diminished 5th / #11 (orange)
    7: 'color-3',  // Perfect 5th (green)
    9: 'color-1',  // Major 6th / Diminished 7th (purple)
    10: 'color-5', // Minor 7th (blue)
    11: 'color-5'  // Major 7th (blue)
  };

  // Scale definitions: intervals from root (in semitones)
  const SCALE_INTERVALS = {
    'major': [0, 2, 4, 5, 7, 9, 11]  // Major scale: Root, 2nd, 3rd, 4th, 5th, 6th, 7th
  };

  // Color scheme for scale functions
  const SCALE_FUNCTION_COLORS = {
    0: 'color-6',  // Root (1) - black
    2: 'color-4',  // 2nd - orange
    4: 'color-2',  // 3rd - red
    5: 'color-1',  // 4th - purple
    7: 'color-3',  // 5th - green
    9: 'color-1',  // 6th - purple
    11: 'color-5'  // 7th - blue
  };

  // Generate chord notes based on root and type
  function getChordNotes(rootNote, chordType) {
    const intervals = CHORD_INTERVALS[chordType];
    if (!intervals) return [];
    
    // Convert root from 0-11 to 1-12 note system
    const root = rootNote + 1; // rootNote is 0-11, need 1-12
    const chordNotes = intervals.map(interval => {
      return ((root - 1 + interval) % 12) + 1; // Calculate note value in 1-12 system
    });
    
    return chordNotes;
  }

  // Display chord notes on the fretboard
  function displayChord(rootNote, chordType, clearFirst, useFunction) {
    if (clearFirst) {
      window.clickedNotes = [];
      window.filledNotes = [];
      window.greyNotes = [];
      clearSelectedNoteDOM();
    }
    
    const chordNotes = getChordNotes(rootNote, chordType);
    const intervals = CHORD_INTERVALS[chordType];
    const config = getCurrentConfig();
    
    // Clear previous chord memory
    window.lastChordNotes = [];
    
    // Create a map from note value to its interval for coloring
    const noteToInterval = {};
    const root = rootNote + 1;
    intervals.forEach(interval => {
      const noteValue = ((root - 1 + interval) % 12) + 1;
      noteToInterval[noteValue] = interval;
    });
    
    if (config.type === 'keyboard') {
      // Add notes to piano
      for (let key = 0; key < config.keys; key++) {
        const noteValue = getNote(key, 0);
        if (chordNotes.includes(noteValue)) {
          // Remove existing note at this position if any
          window.clickedNotes = window.clickedNotes.filter(n => !(n.string === key && n.fret === 0));
          window.filledNotes = window.filledNotes.filter(n => !(n.string === key && n.fret === 0));
          
          // Add the chord note
          const interval = noteToInterval[noteValue];
          const color = useFunction ? CHORD_FUNCTION_COLORS[interval] : window.currentNoteColor;
          window.clickedNotes.push({string: key, fret: 0, type: 'normal', color: color});
          
          // Remember this as a chord note
          window.lastChordNotes.push({string: key, fret: 0});
        }
      }
    } else {
      // Add notes to fretboard
      for (let string = 0; string < config.strings; string++) {
        for (let fret = 0; fret <= 12; fret++) {
          const noteValue = getNote(string, fret);
          if (chordNotes.includes(noteValue)) {
            // Remove existing note at this position if any
            window.clickedNotes = window.clickedNotes.filter(n => !(n.string === string && n.fret === fret));
            window.filledNotes = window.filledNotes.filter(n => !(n.string === string && n.fret === fret));
            
            // Add the chord note
            const interval = noteToInterval[noteValue];
            const color = useFunction ? CHORD_FUNCTION_COLORS[interval] : window.currentNoteColor;
            window.clickedNotes.push({string: string, fret: fret, type: 'normal', color: color});
            
            // Remember this as a chord note
            window.lastChordNotes.push({string: string, fret: fret});
          }
        }
      }
    }
    
    // If using function coloring, enable "Show notes" with function display for chord notes only
    if (useFunction) {
      window.showNotes = true;
      window.showFunction = true;
      window.showAll = false; // Show only clicked notes (which are the chord notes)
      
      // Update UI checkboxes
      const showNotesCheckbox = document.getElementById('show-notes');
      const displayFunctionRadio = document.getElementById('display-function');
      const displaySelectedRadio = document.getElementById('display-selected');
      if (showNotesCheckbox) showNotesCheckbox.checked = true;
      if (displayFunctionRadio) displayFunctionRadio.checked = true;
      if (displaySelectedRadio) displaySelectedRadio.checked = true;
      
      // Select the root note for function display - find first root note that was added to clickedNotes
      const rootNoteValue = rootNote + 1;
      const rootInClicked = window.clickedNotes.find(n => getNote(n.string, n.fret) === rootNoteValue);
      if (rootInClicked) {
        window.selectedNoteKey = noteKey(rootInClicked.string, rootInClicked.fret);
      }
    }
    
    updateFretboard();
  }

  // Display scale notes on the fretboard
  function displayScale(rootNote, clearFirst, useFunction) {
    if (clearFirst) {
      window.clickedNotes = [];
      window.filledNotes = [];
      window.greyNotes = [];
      clearSelectedNoteDOM();
    }
    
    const scaleNotes = getScaleNotes(rootNote);
    const intervals = SCALE_INTERVALS['major'];
    const config = getCurrentConfig();
    
    // Clear previous scale memory
    window.lastScaleNotes = [];
    
    // Create a map from note value to its interval for coloring
    const noteToInterval = {};
    const root = rootNote + 1;
    intervals.forEach(interval => {
      const noteValue = ((root - 1 + interval) % 12) + 1;
      noteToInterval[noteValue] = interval;
    });
    
    if (config.type === 'keyboard') {
      // Add notes to piano
      for (let key = 0; key < config.keys; key++) {
        const noteValue = getNote(key, 0);
        if (scaleNotes.includes(noteValue)) {
          // Remove existing note at this position if any
          window.clickedNotes = window.clickedNotes.filter(n => !(n.string === key && n.fret === 0));
          window.filledNotes = window.filledNotes.filter(n => !(n.string === key && n.fret === 0));
          
          // Add the scale note
          const interval = noteToInterval[noteValue];
          const color = useFunction ? SCALE_FUNCTION_COLORS[interval] : window.currentNoteColor;
          window.clickedNotes.push({string: key, fret: 0, type: 'normal', color: color});
          
          // Remember this as a scale note
          window.lastScaleNotes.push({string: key, fret: 0});
        }
      }
    } else {
      // Add notes to fretboard
      for (let string = 0; string < config.strings; string++) {
        for (let fret = 0; fret <= 12; fret++) {
          const noteValue = getNote(string, fret);
          if (scaleNotes.includes(noteValue)) {
            // Remove existing note at this position if any
            window.clickedNotes = window.clickedNotes.filter(n => !(n.string === string && n.fret === fret));
            window.filledNotes = window.filledNotes.filter(n => !(n.string === string && n.fret === fret));
            
            // Add the scale note
            const interval = noteToInterval[noteValue];
            const color = useFunction ? SCALE_FUNCTION_COLORS[interval] : window.currentNoteColor;
            window.clickedNotes.push({string: string, fret: fret, type: 'normal', color: color});
            
            // Remember this as a scale note
            window.lastScaleNotes.push({string: string, fret: fret});
          }
        }
      }
    }
    
    // If using function coloring, enable "Show notes" with function display for scale notes only
    if (useFunction) {
      window.showNotes = true;
      window.showFunction = true;
      window.showAll = false;
      
      // Update UI checkboxes
      const showNotesCheckbox = document.getElementById('show-notes');
      const displayFunctionRadio = document.getElementById('display-function');
      const displaySelectedRadio = document.getElementById('display-selected');
      if (showNotesCheckbox) showNotesCheckbox.checked = true;
      if (displayFunctionRadio) displayFunctionRadio.checked = true;
      if (displaySelectedRadio) displaySelectedRadio.checked = true;
      
      // Select the root note for function display - find first root note that was added to clickedNotes
      const rootNoteValue = rootNote + 1;
      const rootInClicked = window.clickedNotes.find(n => getNote(n.string, n.fret) === rootNoteValue);
      if (rootInClicked) {
        window.selectedNoteKey = noteKey(rootInClicked.string, rootInClicked.fret);
      }
    }
    
    updateFretboard();
  }

  // Generate scale notes based on root
  function getScaleNotes(rootNote) {
    const intervals = SCALE_INTERVALS['major'];
    if (!intervals) return [];
    
    // Convert root from 0-11 to 1-12 note system
    const root = rootNote + 1;
    const scaleNotes = intervals.map(interval => {
      return ((root - 1 + interval) % 12) + 1;
    });
    
    return scaleNotes;
  }

  window.showNotes = false;
  window.showFunction = false; // false = notes, true = function (intervals)
  window.showAll = false; // false = selected only, true = all
  window.showChordOnly = false; // false = show clicked/all, true = show only chord notes
  window.lastChordNotes = []; // Store the last generated chord notes (format: {string, fret})
  window.lastScaleNotes = []; // Store the last generated scale notes (format: {string, fret})

  function getFretWidth() {
    const baseWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fret-width'));
    const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
    return baseWidth * scale;
  }

  function getStringGap() {
    const baseGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--string-gap'));
    const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
    return baseGap * scale;
  }

  window.clickedNotes = [];
  window.filledNotes = [];
  window.greyNotes = [];
  // Single selected note key (format: "s{string}-f{fret}") - only one selection allowed
  window.selectedNoteKey = null;

  // Current color for next clicked notes
  window.currentNoteColor = 'color-1';
  
  // Initialize fretboard globals to prevent undefined values
  window.currentStartFret = 1;
  window.currentShowOpen = true;
  window.currentMinFret = 0;
  window.currentMaxFret = 12;

  function noteKey(stringIdx, fretIdx) {
    return `s${stringIdx}-f${fretIdx}`;
  }

  function clearSelectedNoteDOM() {
    if (!window.selectedNoteKey) return;
    const prev = document.querySelector(`.note[data-key="${window.selectedNoteKey}"]`);
    if (prev) prev.classList.remove('selected');
    window.selectedNoteKey = null;
  }

  function setSelectedNoteDOM(key) {
    if (window.selectedNoteKey === key) {
      // unselect
      clearSelectedNoteDOM();
      return;
    }
    // remove previous
    clearSelectedNoteDOM();
    const el = document.querySelector(`.note[data-key="${key}"]`);
    if (el) {
      el.classList.add('selected');
      window.selectedNoteKey = key;
    }
  }

  function xForFret(fret) {
    return (fret - window.currentStartFret + 0.5) * getFretWidth();
  }

  function yForString(stringIndex) {
    const gap = getStringGap();
    return stringIndex * gap + gap / 2;
  }

  // Helper function to add selection handlers to notes
  function addNoteSelectionHandlers(note, string, fret) {
    // Long press support for mobile selection
    let longPressTimer = null;
    let isLongPress = false;

    note.addEventListener("touchstart", (e) => {
      isLongPress = false;
      longPressTimer = setTimeout(() => {
        isLongPress = true;
        // Long press = toggle selection
        setSelectedNoteDOM(note.dataset.key);
        // Haptic feedback if available
        if (navigator.vibrate) navigator.vibrate(50);
      }, 500);
    });

    note.addEventListener("touchend", (e) => {
      if (longPressTimer) clearTimeout(longPressTimer);
      if (isLongPress) {
        e.preventDefault();
        e.stopPropagation();
        isLongPress = false;
        return;
      }
    });

    note.addEventListener("touchcancel", (e) => {
      if (longPressTimer) clearTimeout(longPressTimer);
      isLongPress = false;
    });

    note.addEventListener("click", (e) => {
      e.stopPropagation();
      
      // Prevent click after long press
      if (isLongPress) {
        isLongPress = false;
        return;
      }

      // Ctrl+click toggles selection only (do not unclick)
      if (e.ctrlKey) {
        // Only allow selection on actually clicked/filled notes
        setSelectedNoteDOM(note.dataset.key);
        return;
      }

      // Normal click: toggle removal from clicked or filled
      let index = window.clickedNotes.findIndex(n => n.string === string && n.fret === fret);
      if (index !== -1) {
        window.clickedNotes.splice(index, 1);
      } else {
        index = window.filledNotes.findIndex(n => n.string === string && n.fret === fret);
        if (index !== -1) {
          window.filledNotes.splice(index, 1);
        }
      }
      // If the removed note was selected, clear selection
      if (window.selectedNoteKey === note.dataset.key) {
        clearSelectedNoteDOM();
      }
      updateFretboard();
    });
  }

  function renderPiano() {
    const config = getCurrentConfig();
    fretboard.classList.add('piano');
    
    // Clear fretboard
    fretboard.innerHTML = '';
    
    // Create piano container
    const container = document.createElement('div');
    container.className = 'piano-container';
    
    // Generate white keys first
    let whiteKeyIndex = 0;
    for (let i = 0; i < config.keys; i++) {
      if (!isPianoBlackKey(i)) {
        const key = document.createElement('div');
        key.className = 'piano-key white';
        key.dataset.keyindex = i;
        key.dataset.string = i; // Use string for compatibility
        key.dataset.fret = 0;
        container.appendChild(key);
        whiteKeyIndex++;
      }
    }
    
    fretboard.appendChild(container);
    
    // Add black keys positioned absolutely
    const whiteKeys = container.querySelectorAll('.white');
    let whiteKeyCount = 0;
    for (let i = 0; i < config.keys; i++) {
      if (isPianoBlackKey(i)) {
        const key = document.createElement('div');
        key.className = 'piano-key black';
        key.dataset.keyindex = i;
        key.dataset.string = i; // Use string for compatibility
        key.dataset.fret = 0;
        
        // Position based on previous white key
        const prevWhiteKey = whiteKeys[whiteKeyCount];
        if (prevWhiteKey) {
          prevWhiteKey.appendChild(key);
        }
      } else {
        whiteKeyCount++;
      }
    }
    
    // Add notes to keys
    addPianoNotes();
    
    // Scroll to center on middle C (key 39)
    // Middle C is key 39, which corresponds to the 17th white key
    // Each white key is approximately 60px * size-scale
    setTimeout(() => {
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
      const whiteKeyWidth = 60 * scale;
      const middleCWhiteKeyIndex = 17; // Middle C is the 17th white key (0-indexed)
      const middleCPosition = middleCWhiteKeyIndex * whiteKeyWidth;
      const containerWidth = fretboard.clientWidth;
      const scrollPosition = middleCPosition - (containerWidth / 2) + (whiteKeyWidth / 2);
      fretboard.scrollLeft = Math.max(0, scrollPosition);
    }, 0);
  }
  
  function addPianoNotes() {
    const config = getCurrentConfig();
    const allClicked = [...window.clickedNotes, ...window.filledNotes];
    
    // Helper function to find specific key by index
    const findKey = (keyIndex) => {
      const allKeys = fretboard.querySelectorAll('.piano-key');
      for (let key of allKeys) {
        if (parseInt(key.dataset.string) === keyIndex) {
          return key;
        }
      }
      return null;
    };
    
    // Add clicked and filled notes
    allClicked.forEach(noteData => {
      const keyEl = findKey(noteData.string);
      if (!keyEl) return;
      
      const noteNum = getNote(noteData.string, 0);
      const colorToUse = noteData.color || window.currentNoteColor || '';
      
      const note = document.createElement('div');
      note.className = `note ${colorToUse}`;
      note.dataset.key = noteKey(noteData.string, 0);
      note.dataset.string = noteData.string;
      note.dataset.fret = 0;
      
      // Display note name if show notes is enabled
      if (window.showNotes) {
        // When "Chord only" is active (but not "All"), only show text for notes that are in lastChordNotes
        const isInChord = window.lastChordNotes.some(cn => cn.string === noteData.string && cn.fret === 0);
        const shouldShowText = window.showAll || !window.showChordOnly || isInChord;
        
        if (shouldShowText) {
          if (window.showFunction && window.selectedNoteKey) {
            const parts = window.selectedNoteKey.split('-');
            const selString = parseInt(parts[0].substring(1));
            const selFret = parseInt(parts[1].substring(1));
            const refNote = getNote(selString, selFret);
            note.textContent = getInterval(refNote, noteNum);
          } else {
            note.textContent = getNoteName(noteNum);
          }
        }
      }
      
      // Position note at bottom of key
      note.style.position = 'absolute';
      note.style.bottom = '10px';
      note.style.left = '50%';
      note.style.transform = 'translateX(-50%)';
      
      // Add selection handlers
      addNoteSelectionHandlers(note, noteData.string, 0);
      
      keyEl.style.position = 'relative';
      keyEl.appendChild(note);
      
      // apply selected class if this is the selected note
      if (window.selectedNoteKey === note.dataset.key) {
        note.classList.add('selected');
      }
    });
    
    // Add grey notes
    window.greyNotes.forEach(noteData => {
      const keyEl = findKey(noteData.string);
      if (!keyEl) return;
      
      // Check if THIS specific key already has a note (not nested children)
      const existingNotes = Array.from(keyEl.children).filter(child => 
        child.classList.contains('note') && parseInt(child.dataset.string) === noteData.string
      );
      if (existingNotes.length > 0) return;
      
      const noteNum = getNote(noteData.string, 0);
      
      const note = document.createElement('div');
      note.className = 'note grey';
      note.dataset.key = noteKey(noteData.string, 0);
      note.dataset.string = noteData.string;
      note.dataset.fret = 0;
      
      // Display note name if show notes is enabled
      if (window.showNotes) {
        // When "Chord only" is active (but not "All"), only show text for notes that are in lastChordNotes
        const isInChord = window.lastChordNotes.some(cn => cn.string === noteData.string && cn.fret === 0);
        const shouldShowText = window.showAll || !window.showChordOnly || isInChord;
        
        if (shouldShowText) {
          if (window.showFunction && window.selectedNoteKey) {
            const parts = window.selectedNoteKey.split('-');
            const selString = parseInt(parts[0].substring(1));
            const selFret = parseInt(parts[1].substring(1));
            const refNote = getNote(selString, selFret);
            note.textContent = getInterval(refNote, noteNum);
          } else {
            note.textContent = getNoteName(noteNum);
          }
        }
      }
      
      note.style.position = 'absolute';
      note.style.bottom = '10px';
      note.style.left = '50%';
      note.style.transform = 'translateX(-50%)';
      
      // Add selection handlers
      addNoteSelectionHandlers(note, noteData.string, 0);
      
      keyEl.style.position = 'relative';
      keyEl.appendChild(note);
      
      // apply selected class if this is the selected note
      if (window.selectedNoteKey === note.dataset.key) {
        note.classList.add('selected');
      }
    });
    
    // Show all notes if enabled
    if (window.showNotes && window.showAll) {
      const allKeys = fretboard.querySelectorAll('.piano-key');
      allKeys.forEach(keyEl => {
        const keyIndex = parseInt(keyEl.dataset.string);
        if (isNaN(keyIndex)) return;
        
        // Check if THIS specific key already has a note (not nested children)
        const existingNotes = Array.from(keyEl.children).filter(child => 
          child.classList.contains('note') && parseInt(child.dataset.string) === keyIndex
        );
        if (existingNotes.length > 0) return;
        
        const noteNum = getNote(keyIndex, 0);
        const note = document.createElement('div');
        note.className = 'note all-notes-display';
        note.dataset.string = keyIndex;
        note.dataset.fret = 0;
        
        // Display note name or interval
        if (window.showFunction && window.selectedNoteKey) {
          const parts = window.selectedNoteKey.split('-');
          const selString = parseInt(parts[0].substring(1));
          const selFret = parseInt(parts[1].substring(1));
          const refNote = getNote(selString, selFret);
          note.textContent = getInterval(refNote, noteNum);
        } else {
          note.textContent = getNoteName(noteNum);
        }
        
        note.style.position = 'absolute';
        note.style.bottom = '10px';
        note.style.left = '50%';
        note.style.transform = 'translateX(-50%)';
        
        keyEl.style.position = 'relative';
        keyEl.appendChild(note);
      });
    }

    // Note: "Chord only" mode does not display white discs for unclicked chord notes
    // Only the actually clicked/filled chord notes are shown
  }

  function updateFretboard() {
    const config = getCurrentConfig();
    
    // Check if piano and render differently
    if (config.type === 'keyboard') {
      renderPiano();
      return;
    }
    
    // Fretboard instrument logic
    const leftEnd = parseInt(document.getElementById('left-end').value);
    const rightEnd = parseInt(document.getElementById('right-end').value);
    const startFret = leftEnd;
    const endFret = rightEnd;
    const showOpen = startFret === 0;
    const minFret = showOpen ? 0 : startFret;
    const maxFret = endFret;
    const numFrets = showOpen ? endFret : (endFret - startFret + 1);

    // Set globals first
    window.currentStartFret = showOpen ? 1 : startFret;
    window.currentShowOpen = showOpen;
    window.currentMinFret = minFret;
    window.currentMaxFret = maxFret;

    // Update grid for current instrument
    fretboard.classList.remove('piano');
    fretboard.style.gridTemplateRows = `repeat(${config.strings}, calc(var(--string-gap) * var(--size-scale)))`;

    // Clear fretboard except indicator
    const indicator = document.querySelector('.hover-indicator');
    const children = Array.from(fretboard.children);
    children.forEach(child => {
      if (child !== indicator) {
        child.remove();
      }
    });

    // Set grid
    fretboard.style.gridTemplateColumns = `repeat(${numFrets}, calc(var(--fret-width) * var(--size-scale)))`;
    const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
    fretboard.style.borderLeft = showOpen ? `${9 * scale}px solid #222` : 'none';

    // Add open strings
    if (showOpen) {
      for (let string = 0; string < config.strings; string++) {
        const open = document.createElement("div");
        open.className = "open-string";
        open.dataset.string = string;
        open.dataset.fret = 0;
        open.style.top = `${yForString(string)}px`;
        fretboard.appendChild(open);
      }
    }

    // Add cells
    const cellStartFret = showOpen ? 1 : startFret;
    for (let string = 0; string < config.strings; string++) {
      for (let fret = cellStartFret; fret <= endFret; fret++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.string = string;
        cell.dataset.fret = fret;
        fretboard.appendChild(cell);
      }
    }

    // Add markers
    const markerY = (config.strings / 2) * getStringGap();
    MARKER_FRETS.forEach(fret => {
      if (fret >= minFret && fret <= maxFret) {
        const marker = document.createElement("div");
        marker.className = "marker";
        marker.style.left = `${xForFret(fret)}px`;
        marker.style.top = `${markerY}px`;
        fretboard.appendChild(marker);
      }
    });

    // Double marker
    if (DOUBLE_MARKER_FRET >= minFret && DOUBLE_MARKER_FRET <= maxFret) {
      const topMarkerY = (config.strings / 2 - 1) * getStringGap();
      const bottomMarkerY = (config.strings / 2 + 1) * getStringGap();
      const topMarker = document.createElement("div");
      topMarker.className = "marker";
      topMarker.style.left = `${xForFret(DOUBLE_MARKER_FRET)}px`;
      topMarker.style.top = `${topMarkerY}px`;
      fretboard.appendChild(topMarker);
      const bottomMarker = document.createElement("div");
      bottomMarker.className = "marker";
      bottomMarker.style.left = `${xForFret(DOUBLE_MARKER_FRET)}px`;
      bottomMarker.style.top = `${bottomMarkerY}px`;
      fretboard.appendChild(bottomMarker);
    }

    // Add clicked and filled notes in range
    const allClicked = [...window.clickedNotes, ...window.filledNotes];
    allClicked.forEach(noteData => {
      const {string, fret, type} = noteData;
      if (fret >= minFret && fret <= maxFret) {
        const note = document.createElement("div");
        // apply type (root/normal) and color class when present
        const colorClass = noteData.color ? noteData.color : '';
        note.className = `note ${type} ${colorClass}`.trim();
        note.dataset.string = string;
        note.dataset.fret = fret;
        note.dataset.key = noteKey(string, fret);
        if (noteData.color) note.dataset.color = noteData.color;
        note.dataset.key = noteKey(string, fret);

        // Display note name or interval if enabled
        if (window.showNotes) {
          // When "Chord only" is active (but not "All"), only show text for notes that are in lastChordNotes
          const isInChord = window.lastChordNotes.some(cn => cn.string === string && cn.fret === fret);
          const shouldShowText = window.showAll || !window.showChordOnly || isInChord;
          
          if (shouldShowText) {
            const noteNum = getNote(string, fret);
            if (window.showFunction && window.selectedNoteKey) {
              // Show interval relative to selected note
              const selParts = window.selectedNoteKey.split('-');
              const selString = parseInt(selParts[0].slice(1), 10);
              const selFret = parseInt(selParts[1].slice(1), 10);
              const rootNote = getNote(selString, selFret);
              note.textContent = getInterval(rootNote, noteNum);
            } else {
              note.textContent = getNoteName(noteNum);
            }
          }
        }

        if (fret === 0) {
          const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
          note.style.left = `${-4.5 * scale}px`;
          note.style.top = `${yForString(string)}px`;
          note.classList.add("open");
          // Use the stored color for this note when available; otherwise fall back to current palette
          const colorToUse = noteData.color || window.currentNoteColor || '';
          if (colorToUse) {
            note.classList.add(colorToUse);
            note.dataset.color = colorToUse;
          }
        } else {
          note.style.left = `${xForFret(fret)}px`;
          note.style.top = `${yForString(string)}px`;
        }

        // Add selection handlers
        addNoteSelectionHandlers(note, string, fret);

        fretboard.appendChild(note);
        // apply selected class if this is the selected note
        if (window.selectedNoteKey === note.dataset.key) {
          note.classList.add('selected');
        }
      }
    });

    // Add grey notes in range, if not clicked or filled
    window.greyNotes.forEach(noteData => {
      const {string, fret} = noteData;
      if (fret >= minFret && fret <= maxFret) {
        const isSelected = allClicked.some(n => n.string === string && n.fret === fret);
        if (!isSelected) {
          const note = document.createElement("div");
          note.className = `note grey`;
          note.dataset.string = string;
          note.dataset.fret = fret;
          note.dataset.key = noteKey(string, fret);

          // Display note name or interval if enabled
          if (window.showNotes) {
            // When "Chord only" is active (but not "All"), only show text for notes that are in lastChordNotes
            const isInChord = window.lastChordNotes.some(cn => cn.string === string && cn.fret === fret);
            const shouldShowText = window.showAll || !window.showChordOnly || isInChord;
            
            if (shouldShowText) {
              const noteNum = getNote(string, fret);
              if (window.showFunction && window.selectedNoteKey) {
                const selParts = window.selectedNoteKey.split('-');
                const selString = parseInt(selParts[0].slice(1), 10);
                const selFret = parseInt(selParts[1].slice(1), 10);
                const rootNote = getNote(selString, selFret);
                note.textContent = getInterval(rootNote, noteNum);
              } else {
                note.textContent = getNoteName(noteNum);
              }
            }
          }

          if (fret === 0) {
            const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
            note.style.left = `${-4.5 * scale}px`;
            note.style.top = `${yForString(string)}px`;
            note.classList.add("open");
          } else {
            note.style.left = `${xForFret(fret)}px`;
            note.style.top = `${yForString(string)}px`;
          }

          // Grey notes - only handle click (no selection needed)
          note.addEventListener("click", (e) => {
            e.stopPropagation();
            // Ctrl+click on grey does nothing (selection only for clicked/filled notes)
            if (e.ctrlKey) return;
            // Add to clicked
            const exists = window.clickedNotes.some(n => n.string === string && n.fret === fret);
            if (!exists) {
              window.clickedNotes.push({string, fret, type: 'normal', color: window.currentNoteColor});
            }
            // Remove from grey
            const greyIndex = window.greyNotes.findIndex(n => n.string === string && n.fret === fret);
            if (greyIndex !== -1) {
              window.greyNotes.splice(greyIndex, 1);
            }
            updateFretboard();
          });

          fretboard.appendChild(note);
          // if this is the selected note key (shouldn't be for grey, but keep consistent)
          if (window.selectedNoteKey === note.dataset.key) note.classList.add('selected');
        }
      }
    });

    // Show all notes when enabled - display white discs for unclicked cells
    if (window.showNotes && window.showAll) {
      const cellStartFret = showOpen ? 0 : startFret;
      for (let string = 0; string < config.strings; string++) {
        for (let fret = cellStartFret; fret <= endFret; fret++) {
          // Skip if this position already has a clicked/filled note or grey note
          const hasClicked = allClicked.some(n => n.string === string && n.fret === fret);
          const hasGrey = window.greyNotes.some(n => n.string === string && n.fret === fret);
          if (!hasClicked && !hasGrey) {
            const note = document.createElement("div");
            note.className = `note all-notes-display`;
            note.dataset.string = string;
            note.dataset.fret = fret;
            note.dataset.key = noteKey(string, fret);
            const noteNum = getNote(string, fret);
            if (window.showFunction && window.selectedNoteKey) {
              const selParts = window.selectedNoteKey.split('-');
              const selString = parseInt(selParts[0].slice(1), 10);
              const selFret = parseInt(selParts[1].slice(1), 10);
              const rootNote = getNote(selString, selFret);
              note.textContent = getInterval(rootNote, noteNum);
            } else {
              note.textContent = getNoteName(noteNum);
            }

            if (fret === 0) {
              const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
              note.style.left = `${-4.5 * scale}px`;
              note.style.top = `${yForString(string)}px`;
              note.classList.add("open");
            } else {
              note.style.left = `${xForFret(fret)}px`;
              note.style.top = `${yForString(string)}px`;
            }

            // All-notes display - only handle click (no selection needed)
            note.addEventListener("click", (e) => {
              e.stopPropagation();
              if (e.ctrlKey) return;
              // Add to clicked
              window.clickedNotes.push({string, fret, type: 'normal', color: window.currentNoteColor});
              updateFretboard();
            });

            fretboard.appendChild(note);
          }
        }
      }
    }

    // Note: "Chord only" mode does not display white discs for unclicked chord notes
    // Only the actually clicked/filled chord notes are shown

    // Add fret number label if not showing open
    if (!showOpen) {
      const label = document.createElement('div');
      label.textContent = startFret;
      label.style.position = 'absolute';
      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
      label.style.top = `${-30 * scale}px`;
      label.style.left = `${0.5 * getFretWidth()}px`;
      label.style.transform = 'translateX(-50%)';
      label.style.fontSize = `${21 * scale}px`;
      label.style.fontWeight = 'bold';
      label.style.color = '#222';
      label.style.pointerEvents = 'none';
      fretboard.appendChild(label);
    }
  }

  (function () {
    const fretboard = document.getElementById('fretboard');

    function updateIndicatorFromEvent(e) {
      const rect = fretboard.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      let stringIndex = Math.floor(y / getStringGap());
      const config = getCurrentConfig();
      stringIndex = Math.max(0, Math.min(config.strings - 1, stringIndex));

      let fret;
      const openThreshold = getFretWidth() * 0.25;
      if (window.currentShowOpen && x < openThreshold) {
        fret = 0;
      } else {
        fret = Math.ceil(x / getFretWidth()) + window.currentStartFret - 1;
        fret = Math.max(window.currentMinFret, Math.min(window.currentMaxFret, fret));
      }

      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size-scale'));
      const left = fret === 0 ? -4.5 * scale : xForFret(fret);
      const top = yForString(stringIndex);

      indicator.style.left = `${left}px`;
      indicator.style.top = `${top}px`;
      indicator.dataset.string = String(stringIndex);
      indicator.dataset.fret = String(fret);
    }

    const indicator = document.createElement('div');
    indicator.className = 'hover-indicator';
    fretboard.appendChild(indicator);

    fretboard.addEventListener('mousemove', (e) => {
      updateIndicatorFromEvent(e);
      indicator.classList.add('visible');
    });

    fretboard.addEventListener('mouseenter', (e) => {
      updateIndicatorFromEvent(e);
      indicator.classList.add('visible');
    });

    fretboard.addEventListener('mouseleave', () => {
      indicator.classList.remove('visible');
    });
  })();

  (function () {
    const title = document.getElementById("title");
    if (!title) return;

    title.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        title.blur();
      }
    });
  })();

  document.getElementById('left-end').addEventListener('input', updateFretboard);
  document.getElementById('right-end').addEventListener('input', updateFretboard);

  // Reset to default values on load
  document.getElementById('left-end').value = '0';
  document.getElementById('right-end').value = '12';

  document.getElementById('fill-toggle').addEventListener('click', () => {
    // Toggle between fill and unfill-all
    if (window.filledNotes.length > 0 || window.greyNotes.length > 0) {
      window.filledNotes = [];
      window.greyNotes = [];
    } else {
      // Build a mapping noteNumber -> color from clicked notes (first occurrence wins)
      const colorMap = {};
      window.clickedNotes.forEach(n => {
        const noteNum = getNote(n.string, n.fret);
        if (!colorMap[noteNum]) colorMap[noteNum] = n.color || window.currentNoteColor;
      });
      // Get unique note numbers from clicked notes
      const uniqueNotes = Array.from(new Set(window.clickedNotes.map(n => getNote(n.string, n.fret))));
      // For each unique note, add all positions with that note to filled, preserving color when possible
      const config = getCurrentConfig();
      uniqueNotes.forEach(note => {
        const fillColor = colorMap[note] || window.currentNoteColor;
        if (config.type === 'keyboard') {
          // For piano: fill all keys with same note
          for (let k = 0; k < config.keys; k++) {
            if (getNote(k, 0) === note) {
              const exists = window.filledNotes.some(n => n.string === k && n.fret === 0);
              if (!exists) {
                window.filledNotes.push({string: k, fret: 0, type: 'normal', color: fillColor});
              }
            }
          }
        } else {
          // For fretboard instruments
          for (let s = 0; s < config.strings; s++) {
            for (let f = 0; f <= 12; f++) { // assuming max fret 12
              if (getNote(s, f) === note) {
                const exists = window.filledNotes.some(n => n.string === s && n.fret === f);
                if (!exists) {
                  window.filledNotes.push({string: s, fret: f, type: 'normal', color: fillColor});
                }
              }
            }
          }
        }
      });
    }
    updateFretboard();
  });

  document.getElementById('fill-grey-toggle').addEventListener('click', () => {
    // Toggle between fill-grey and unfill-grey
    if (window.greyNotes.length > 0) {
      window.greyNotes = [];
    } else {
      // Get unique notes from current clicked notes
      const uniqueNotes = new Set(window.clickedNotes.map(n => getNote(n.string, n.fret)));
      // For each unique note, add all positions with that note to grey
      const config = getCurrentConfig();
      uniqueNotes.forEach(note => {
        if (config.type === 'keyboard') {
          // For piano: fill all keys with same note
          for (let k = 0; k < config.keys; k++) {
            if (getNote(k, 0) === note) {
              const exists = window.greyNotes.some(n => n.string === k && n.fret === 0);
              if (!exists) {
                window.greyNotes.push({string: k, fret: 0});
              }
            }
          }
        } else {
          // For fretboard instruments
          for (let s = 0; s < config.strings; s++) {
            for (let f = 0; f <= 12; f++) { // assuming max fret 12
              if (getNote(s, f) === note) {
                const exists = window.greyNotes.some(n => n.string === s && n.fret === f);
                if (!exists) {
                  window.greyNotes.push({string: s, fret: f});
                }
              }
            }
          }
        }
      });
    }
    updateFretboard();
  });

  // Clear all notes and selection
  document.getElementById('clear').addEventListener('click', () => {
    window.clickedNotes = [];
    window.filledNotes = [];
    window.greyNotes = [];
    window.lastChordNotes = []; // Clear chord memory
    window.lastScaleNotes = []; // Clear scale memory
    if (typeof clearSelectedNoteDOM === 'function') clearSelectedNoteDOM();
    updateFretboard();
  });

  // Chord display buttons
  document.getElementById('chord-clear-show').addEventListener('click', () => {
    const rootNote = parseInt(document.getElementById('chord-root').value);
    const chordType = document.getElementById('chord-type').value;
    const useFunction = document.getElementById('chord-color-function').checked;
    displayChord(rootNote, chordType, true, useFunction);
  });

  document.getElementById('chord-show-top').addEventListener('click', () => {
    const rootNote = parseInt(document.getElementById('chord-root').value);
    const chordType = document.getElementById('chord-type').value;
    const useFunction = document.getElementById('chord-color-function').checked;
    displayChord(rootNote, chordType, false, useFunction);
  });

  // Scale display buttons
  document.getElementById('scale-clear-show').addEventListener('click', () => {
    const rootNote = parseInt(document.getElementById('scale-root').value);
    const useFunction = document.getElementById('scale-color-function').checked;
    displayScale(rootNote, true, useFunction);
  });

  document.getElementById('scale-show-top').addEventListener('click', () => {
    const rootNote = parseInt(document.getElementById('scale-root').value);
    const useFunction = document.getElementById('scale-color-function').checked;
    displayScale(rootNote, false, useFunction);
  });

  document.getElementById('fill-selected-toggle').addEventListener('click', () => {
    if (!window.selectedNoteKey) return;
    // parse selected key like s{string}-f{fret}
    const parts = window.selectedNoteKey.split('-');
    const s = parseInt(parts[0].slice(1), 10);
    const f = parseInt(parts[1].slice(1), 10);
    const targetNote = getNote(s, f);
    
    // determine source color from the selected note if available
    let sourceColor = window.currentNoteColor;
    const selClicked = window.clickedNotes.find(n => n.string === s && n.fret === f);
    if (selClicked && selClicked.color) sourceColor = selClicked.color;
    const selFilled = window.filledNotes.find(n => n.string === s && n.fret === f);
    if (!selClicked && selFilled && selFilled.color) sourceColor = selFilled.color;
    
    const config = getCurrentConfig();
    
    // Collect all positions that have the same note
    const allMatchingPositions = [];
    if (config.type === 'keyboard') {
      for (let k = 0; k < config.keys; k++) {
        if (getNote(k, 0) === targetNote) {
          allMatchingPositions.push({string: k, fret: 0});
        }
      }
    } else {
      for (let ss = 0; ss < config.strings; ss++) {
        for (let ff = 0; ff <= 12; ff++) {
          if (getNote(ss, ff) === targetNote) {
            allMatchingPositions.push({string: ss, fret: ff});
          }
        }
      }
    }
    
    // Check if all matching positions are clicked
    const allClicked = allMatchingPositions.every(pos => 
      window.clickedNotes.some(n => n.string === pos.string && n.fret === pos.fret)
    );
    
    if (allClicked) {
      // If all are clicked, unclick and unfill all matching notes INCLUDING the selected note
      window.clickedNotes = window.clickedNotes.filter(n => getNote(n.string, n.fret) !== targetNote);
      window.filledNotes = window.filledNotes.filter(n => getNote(n.string, n.fret) !== targetNote);
      window.greyNotes = window.greyNotes.filter(n => getNote(n.string, n.fret) !== targetNote);
    } else {
      // If not all are clicked, click all matching notes
      for (const pos of allMatchingPositions) {
        const alreadyClicked = window.clickedNotes.some(n => n.string === pos.string && n.fret === pos.fret);
        if (!alreadyClicked) {
          window.clickedNotes.push({string: pos.string, fret: pos.fret, type: 'normal', color: sourceColor});
        }
      }
    }
    updateFretboard();
  });

  // Color palette interactions
  (function initPalette() {
    const swatches = document.querySelectorAll('.color-swatch');
    swatches.forEach(s => {
      s.addEventListener('click', () => {
        swatches.forEach(x => x.classList.remove('selected'));
        s.classList.add('selected');
        window.currentNoteColor = s.dataset.color;
      });
    });
  })();

  // Size slider control
  (function initSizeSlider() {
    const slider = document.getElementById('size-slider');
    const valueDisplay = document.getElementById('size-value');
    if (!slider || !valueDisplay) return;

    slider.addEventListener('input', () => {
      const scale = parseFloat(slider.value);
      document.documentElement.style.setProperty('--size-scale', scale);
      valueDisplay.textContent = `${scale.toFixed(1)}x`;
      updateFretboard();
    });
  })();

  // Note display controls
  (function initNoteDisplayToggles() {
    const showNotesCheckbox = document.getElementById('show-notes');
    const displayNotesRadio = document.getElementById('display-notes');
    const displayFunctionRadio = document.getElementById('display-function');
    const displaySelectedRadio = document.getElementById('display-selected');
    const displayAllRadio = document.getElementById('display-all');
    
    if (!showNotesCheckbox || !displayNotesRadio || !displayFunctionRadio || !displaySelectedRadio || !displayAllRadio) return;

    // Force default state on page load
    showNotesCheckbox.checked = false;
    displayNotesRadio.checked = true;
    displaySelectedRadio.checked = true;
    window.showNotes = false;
    window.showFunction = false;
    window.showAll = false;
    window.showChordOnly = false;

    showNotesCheckbox.addEventListener('change', () => {
      window.showNotes = showNotesCheckbox.checked;
      updateFretboard();
    });

    displayNotesRadio.addEventListener('change', () => {
      if (displayNotesRadio.checked) {
        window.showFunction = false;
        updateFretboard();
      }
    });

    displayFunctionRadio.addEventListener('change', () => {
      if (displayFunctionRadio.checked) {
        if (!window.selectedNoteKey) {
          alert('Select a note first');
          displayNotesRadio.checked = true;
          displayFunctionRadio.checked = false;
          return;
        }
        window.showFunction = true;
        updateFretboard();
      }
    });

    displaySelectedRadio.addEventListener('change', () => {
      if (displaySelectedRadio.checked) {
        window.showAll = false;
        window.showChordOnly = false;
        updateFretboard();
      }
    });

    displayAllRadio.addEventListener('change', () => {
      if (displayAllRadio.checked) {
        window.showAll = true;
        window.showChordOnly = false;
        updateFretboard();
      }
    });

    const displayChordRadio = document.getElementById('display-chord');
    if (displayChordRadio) {
      displayChordRadio.addEventListener('change', () => {
        if (displayChordRadio.checked) {
          if (window.lastChordNotes.length === 0) {
            alert('No chord generated yet. Use "Display Chord" first.');
            displaySelectedRadio.checked = true;
            return;
          }
          window.showAll = false;
          window.showChordOnly = true;
          updateFretboard();
        }
      });
    }
  })();

  // Instrument selector
  (function initInstrumentSelector() {
    const instrumentSelect = document.getElementById('instrument-select');
    if (!instrumentSelect) return;

    // Force guitar on page load
    instrumentSelect.value = 'guitar';
    window.currentInstrument = 'guitar';
    
    // Force keep-notes unchecked on page load
    const keepNotesCheckbox = document.getElementById('keep-notes');
    if (keepNotesCheckbox) {
      keepNotesCheckbox.checked = false;
    }

    instrumentSelect.addEventListener('change', () => {
      const oldInstrument = window.currentInstrument;
      const newInstrument = instrumentSelect.value;
      const keepNotes = document.getElementById('keep-notes')?.checked || false;
      
      // Store the absolute pitch of the selected note before switching
      let selectedNotePitch = null;
      if (window.selectedNoteKey) {
        const parts = window.selectedNoteKey.split('-');
        const selString = parseInt(parts[0].substring(1));
        const selFret = parseInt(parts[1].substring(1));
        const oldConfig = INSTRUMENTS[oldInstrument];
        selectedNotePitch = getAbsolutePitch(selString, selFret, oldConfig);
      }
      
      // Convert notes to new instrument if keep-notes is checked
      if (keepNotes) {
        convertNotesToNewInstrument(oldInstrument, newInstrument);
      } else {
        // Clear all notes when changing instrument
        window.clickedNotes = [];
        window.filledNotes = [];
        window.greyNotes = [];
      }
      
      window.currentInstrument = newInstrument;
      const config = getCurrentConfig();
      
      // Show/hide Left/Right end controls based on instrument type
      const leftRightControls = document.querySelector('[for="left-end"]').closest('div');
      if (leftRightControls) {
        leftRightControls.style.display = (config.type === 'keyboard') ? 'none' : 'flex';
      }
      
      // Convert selectedNoteKey to the new instrument
      window.selectedNoteKey = null;
      if (selectedNotePitch !== null) {
        // Find the first occurrence of this pitch on the new instrument
        if (config.type === 'keyboard') {
          // Search piano keys
          for (let key = 0; key < config.keys; key++) {
            const pitch = getAbsolutePitch(key, 0, config);
            if (pitch === selectedNotePitch) {
              window.selectedNoteKey = noteKey(key, 0);
              break;
            }
          }
        } else {
          // Search fretboard
          let found = false;
          for (let fret = 0; fret <= 12 && !found; fret++) {
            for (let string = 0; string < config.strings && !found; string++) {
              const pitch = getAbsolutePitch(string, fret, config);
              if (pitch === selectedNotePitch) {
                window.selectedNoteKey = noteKey(string, fret);
                found = true;
              }
            }
          }
        }
      }
      
      // Reset left/right end values to defaults for fretboard instruments
      if (config.type !== 'keyboard') {
        const leftEndInput = document.getElementById('left-end');
        const rightEndInput = document.getElementById('right-end');
        if (leftEndInput) leftEndInput.value = 0;
        if (rightEndInput) rightEndInput.value = 12;
      }
      
      updateFretboard();
    });
  })();

  // Note system toggle (letter vs solfÃ¨ge)
  (function initNoteSystemToggle() {
    const lettersRadio = document.getElementById('use-letters');
    const solfegeRadio = document.getElementById('use-solfege');
    if (!lettersRadio || !solfegeRadio) return;

    // Force letter notation on page load
    lettersRadio.checked = true;
    solfegeRadio.checked = false;
    window.useSolfege = false;

    lettersRadio.addEventListener('change', () => {
      if (lettersRadio.checked) {
        window.useSolfege = false;
        updateFretboard();
      }
    });

    solfegeRadio.addEventListener('change', () => {
      if (solfegeRadio.checked) {
        window.useSolfege = true;
        updateFretboard();
      }
    });
  })();

  // Sharp/flat notation toggle
  (function initNotationToggle() {
    const sharpsRadio = document.getElementById('use-sharps');
    const flatsRadio = document.getElementById('use-flats');
    if (!sharpsRadio || !flatsRadio) return;

    // Force sharps on page load
    sharpsRadio.checked = true;
    flatsRadio.checked = false;
    window.useSharps = true;

    sharpsRadio.addEventListener('change', () => {
      if (sharpsRadio.checked) {
        window.useSharps = true;
        updateFretboard();
      }
    });

    flatsRadio.addEventListener('change', () => {
      if (flatsRadio.checked) {
        window.useSharps = false;
        updateFretboard();
      }
    });
  })();

  // Tritone notation toggle (4+ vs 5-)
  (function initTritoneToggle() {
    const tritoneAugRadio = document.getElementById('use-tritone-aug');
    const tritoneDimRadio = document.getElementById('use-tritone-dim');
    if (!tritoneAugRadio || !tritoneDimRadio) return;

    // Force 4+ on page load
    tritoneAugRadio.checked = true;
    tritoneDimRadio.checked = false;
    window.useTritoneAugmented = true;

    tritoneAugRadio.addEventListener('change', () => {
      if (tritoneAugRadio.checked) {
        window.useTritoneAugmented = true;
        updateFretboard();
      }
    });

    tritoneDimRadio.addEventListener('change', () => {
      if (tritoneDimRadio.checked) {
        window.useTritoneAugmented = false;
        updateFretboard();
      }
    });
  })();

  // Keyboard shortcuts
  (function initKeyboardShortcuts() {
    // Track mouse position globally
    let mouseX = 0;
    let mouseY = 0;
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    document.addEventListener('keydown', (e) => {
      // Don't trigger shortcuts when typing in text input fields, but allow for checkboxes/radio buttons
      if (e.target.tagName === 'TEXTAREA' || (e.target.tagName === 'INPUT' && !['checkbox', 'radio'].includes(e.target.type))) return;
      
      // Don't interfere with browser shortcuts (Ctrl+F, Ctrl+S, etc.)
      if (e.ctrlKey || e.metaKey || e.altKey) return;
      
      const key = e.key.toLowerCase();
      
      if (key === 'c') {
        e.preventDefault();
        // Toggle floating color palette at mouse position
        const floatingPalette = document.getElementById('floating-color-palette');
        if (floatingPalette.classList.contains('visible')) {
          floatingPalette.classList.remove('visible');
        } else {
          // Position at mouse location
          floatingPalette.style.left = `${mouseX + 10}px`;
          floatingPalette.style.top = `${mouseY + 10}px`;
          floatingPalette.classList.add('visible');
        }
      } else if (key === 'f') {
        e.preventDefault();
        document.getElementById('fill-toggle').click();
      } else if (key === 'g') {
        e.preventDefault();
        document.getElementById('fill-grey-toggle').click();
      } else if (key === 's') {
        e.preventDefault();
        if (!window.selectedNoteKey) return;
        document.getElementById('fill-selected-toggle').click();
      } else if (key === '+' || key === '=') {
        e.preventDefault();
        // Increase size
        const slider = document.getElementById('size-slider');
        const valueDisplay = document.getElementById('size-value');
        if (slider && valueDisplay) {
          let newValue = parseFloat(slider.value) + 0.05;
          newValue = Math.min(parseFloat(slider.max), newValue);
          slider.value = newValue;
          document.documentElement.style.setProperty('--size-scale', newValue);
          valueDisplay.textContent = `${newValue.toFixed(1)}x`;
          updateFretboard();
        }
      } else if (key === '-' || key === '_') {
        e.preventDefault();
        // Decrease size
        const slider = document.getElementById('size-slider');
        const valueDisplay = document.getElementById('size-value');
        if (slider && valueDisplay) {
          let newValue = parseFloat(slider.value) - 0.05;
          newValue = Math.max(parseFloat(slider.min), newValue);
          slider.value = newValue;
          document.documentElement.style.setProperty('--size-scale', newValue);
          valueDisplay.textContent = `${newValue.toFixed(1)}x`;
          updateFretboard();
        }
      }
    });
  })();

  // Help panel toggle
  (function initHelpPanel() {
    const helpButton = document.getElementById('help-button');
    const helpPanel = document.getElementById('help-panel');
    if (!helpButton || !helpPanel) return;
    
    helpButton.addEventListener('click', (e) => {
      e.stopPropagation();
      helpPanel.classList.toggle('visible');
    });
    
    // Close help panel when clicking outside
    document.addEventListener('click', (e) => {
      if (!helpPanel.contains(e.target) && !helpButton.contains(e.target)) {
        helpPanel.classList.remove('visible');
      }
    });
  })();

  // Floating color palette interactions
  (function initFloatingPalette() {
    const floatingPalette = document.getElementById('floating-color-palette');
    const swatches = floatingPalette.querySelectorAll('.color-swatch');
    const mainSwatches = document.querySelectorAll('.color-palette .color-swatch');
    
    swatches.forEach(swatch => {
      swatch.addEventListener('click', () => {
        // Update current color
        window.currentNoteColor = swatch.dataset.color;
        
        // Update main palette selection
        mainSwatches.forEach(s => s.classList.remove('selected'));
        const mainSwatch = document.querySelector(`.color-palette .color-swatch[data-color="${swatch.dataset.color}"]`);
        if (mainSwatch) mainSwatch.classList.add('selected');
        
        // Hide floating palette
        floatingPalette.classList.remove('visible');
      });
    });
    
    // Hide palette when clicking outside
    document.addEventListener('click', (e) => {
      if (!floatingPalette.contains(e.target) && floatingPalette.classList.contains('visible')) {
        floatingPalette.classList.remove('visible');
      }
    });
    
    // Hide palette on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && floatingPalette.classList.contains('visible')) {
        floatingPalette.classList.remove('visible');
      }
    });
  })();

  updateFretboard();
</script>

<!-- 
##############################################################
Add clicable notes
##############################################################
-->

<script>

  fretboard.addEventListener("click", (event) => {
    const target =
      event.target.closest(".cell") ||
      event.target.closest(".open-string") ||
      event.target.closest(".piano-key");

    if (!target) return;

    const string = parseInt(target.dataset.string, 10);
    const fret = parseInt(target.dataset.fret, 10);

    const existingIndex = window.clickedNotes.findIndex(n => n.string === string && n.fret === fret);
    if (existingIndex !== -1) {
      window.clickedNotes.splice(existingIndex, 1);
      console.log('Removed note:', string, fret);
    } else {
      window.clickedNotes.push({string, fret, type: 'normal', color: window.currentNoteColor});
      console.log('Added note on', window.currentInstrument, '- string:', string, 'fret:', fret, 'color:', window.currentNoteColor);
    }
    updateFretboard();
  });
  
  // Delete notes on hover while 'd' key is pressed
  fretboard.addEventListener("mouseover", (event) => {
    if (!window.deleteMode) return;
    
    const target =
      event.target.closest(".cell") ||
      event.target.closest(".open-string") ||
      event.target.closest(".piano-key");

    if (!target) return;

    const string = parseInt(target.dataset.string, 10);
    const fret = parseInt(target.dataset.fret, 10);

    // Remove from clickedNotes if exists
    const clickedIndex = window.clickedNotes.findIndex(n => n.string === string && n.fret === fret);
    if (clickedIndex !== -1) {
      window.clickedNotes.splice(clickedIndex, 1);
      updateFretboard();
      return;
    }
    
    // Remove from filledNotes if exists
    const filledIndex = window.filledNotes.findIndex(n => n.string === string && n.fret === fret);
    if (filledIndex !== -1) {
      window.filledNotes.splice(filledIndex, 1);
      updateFretboard();
      return;
    }
    
    // Remove from greyNotes if exists
    const greyIndex = window.greyNotes.findIndex(n => n.string === string && n.fret === fret);
    if (greyIndex !== -1) {
      window.greyNotes.splice(greyIndex, 1);
      updateFretboard();
    }
  });

</script>

<!-- 
##############################################################
Export
##############################################################
-->

<script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>

<script>

  // PNG export
  //document.addEventListener("DOMContentLoaded", () => {
  //  const exportBtn = document.getElementById("export-png");
//
  //  exportBtn.addEventListener("click", () => {
  //    const node = document.getElementById("fretboard");
  //    
  //    
//
  //    domtoimage.toPng(document.getElementById("fretboard"))
  //      .then(dataUrl => {
  //        const link = document.createElement("a");
  //        link.download = "manche-guitare.png";
  //        link.href = dataUrl;
  //        link.click();
  //      })
  //      .catch(err => {
  //        console.error("Erreur export PNG", err);
  //      });
  //  });
  //});

  //document.getElementById("export-png").addEventListener("click", () => {
  //const node = document.getElementById("fretboard");
//
  //const width = node.scrollWidth;
  //const height = node.scrollHeight;
//
  //htmlToImage.toPng(node, {
  //  backgroundColor: "#ffffff",
  //  width,
  //  height,
  //  style: {
  //    width: `${width+50}px`,
  //    height: `${height+500}px`
  //  }
  //})
  //.then(dataUrl => {
  //  const link = document.createElement("a");
  //  link.download = "manche-guitare.png";
  //  link.href = dataUrl;
  //  link.click();
  //})
  //.catch(err => {
  //  console.error("Erreur export PNG", err);
  //});
//});

document.getElementById("export-png").addEventListener("click", () => {
  const node = document.getElementById("export-area");
  const fretboard = document.getElementById("fretboard");
  const isPiano = fretboard && fretboard.classList.contains('piano');

  // Get selected quality
  const qualitySelect = document.getElementById('png-quality');
  const pixelRatio = qualitySelect ? parseInt(qualitySelect.value) : 2;

  // For piano, hide scrollbar and adjust to show visible portion
  let originalOverflow = null;
  let pianoContainer = null;
  let originalTransform = null;
  let scrollLeft = 0;
  
  if (isPiano) {
    originalOverflow = fretboard.style.overflow;
    fretboard.style.overflowX = 'hidden';
    
    // Get scroll position and adjust container
    scrollLeft = fretboard.scrollLeft;
    pianoContainer = fretboard.querySelector('.piano-container');
    if (pianoContainer) {
      originalTransform = pianoContainer.style.transform;
      pianoContainer.style.transform = `translateX(-${scrollLeft}px)`;
    }
  }

  const width = node.offsetWidth;
  const height = node.offsetHeight;

  htmlToImage.toPng(node, {
    backgroundColor: "#ffffff",
    width,
    height,
    pixelRatio: pixelRatio,
    cacheBust: true,
    style: {
      margin: "0",
      padding: "0",
      width: `${width}px`,
      height: `${height}px`,
    }
  })
  .then(dataUrl => {
    // Restore scrollbar and container position
    if (isPiano) {
      if (originalOverflow !== null) {
        fretboard.style.overflowX = originalOverflow;
      }
      if (pianoContainer && originalTransform !== null) {
        pianoContainer.style.transform = originalTransform;
      }
    }

    const link = document.createElement("a");

    // Determine filename from editable title when possible
    const titleEl = document.getElementById("title");
    let baseName = "manche-guitare";
    if (titleEl) {
      try {
        const text = titleEl.value.trim();
        if (text) baseName = text;
      } catch (e) {
        // ignore
      }
    }

    // Sanitize for filesystem (remove invalid Windows filename chars)
    baseName = baseName.replace(/[\\\/:\*\?"<>\|]/g, "");
    // Collapse whitespace to single hyphen and trim
    baseName = baseName.replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
    if (!baseName) baseName = "manche-guitare";
    baseName = baseName.slice(0, 200);

    link.download = `${baseName}.png`;
    link.href = dataUrl;
    link.click();
  })
  .catch(err => {
    // Restore scrollbar and container position on error
    if (isPiano) {
      if (originalOverflow !== null) {
        fretboard.style.overflowX = originalOverflow;
      }
      if (pianoContainer && originalTransform !== null) {
        pianoContainer.style.transform = originalTransform;
      }
    }
    console.error("Erreur export PNG", err);
  });
});

// SVG export
document.getElementById("export-svg").addEventListener("click", () => {
  const node = document.getElementById("export-area");
  const fretboard = document.getElementById("fretboard");
  const isPiano = fretboard && fretboard.classList.contains('piano');

  // For piano, hide scrollbar and adjust to show visible portion
  let originalOverflow = null;
  let pianoContainer = null;
  let originalTransform = null;
  let scrollLeft = 0;
  
  if (isPiano) {
    originalOverflow = fretboard.style.overflow;
    fretboard.style.overflowX = 'hidden';
    
    // Get scroll position and adjust container
    scrollLeft = fretboard.scrollLeft;
    pianoContainer = fretboard.querySelector('.piano-container');
    if (pianoContainer) {
      originalTransform = pianoContainer.style.transform;
      pianoContainer.style.transform = `translateX(-${scrollLeft}px)`;
    }
  }

  const width = node.offsetWidth;
  const height = node.offsetHeight;

  htmlToImage.toSvg(node, {
    backgroundColor: "#ffffff",
    width,
    height,
    cacheBust: true,
    style: {
      margin: "0",
      padding: "0",
      width: `${width}px`,
      height: `${height}px`,
    }
  })
  .then(dataUrl => {
    // Restore scrollbar and container position
    if (isPiano) {
      if (originalOverflow !== null) {
        fretboard.style.overflowX = originalOverflow;
      }
      if (pianoContainer && originalTransform !== null) {
        pianoContainer.style.transform = originalTransform;
      }
    }

    const link = document.createElement("a");

    // Determine filename from editable title when possible
    const titleEl = document.getElementById("title");
    let baseName = "manche-guitare";
    if (titleEl) {
      try {
        const text = titleEl.value.trim();
        if (text) baseName = text;
      } catch (e) {
        // ignore
      }
    }

    // Sanitize for filesystem (remove invalid Windows filename chars)
    baseName = baseName.replace(/[\\\/:*?"<>|]/g, "");
    // Collapse whitespace to single hyphen and trim
    baseName = baseName.replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
    if (!baseName) baseName = "manche-guitare";
    baseName = baseName.slice(0, 200);

    link.download = `${baseName}.svg`;
    link.href = dataUrl;
    link.click();
  })
  .catch(err => {
    // Restore scrollbar and container position on error
    if (isPiano) {
      if (originalOverflow !== null) {
        fretboard.style.overflowX = originalOverflow;
      }
      if (pianoContainer && originalTransform !== null) {
        pianoContainer.style.transform = originalTransform;
      }
    }
    console.error("Erreur export SVG", err);
  });
});

// Save diagram as JSON
document.getElementById("save-diagram").addEventListener("click", () => {
  // Collect all state data
  const diagramData = {
    version: "1.0",
    timestamp: new Date().toISOString(),
    instrument: window.currentInstrument || 'guitar',
    title: document.getElementById("title")?.value || "Untitled",
    clickedNotes: window.clickedNotes || [],
    filledNotes: window.filledNotes || [],
    greyNotes: window.greyNotes || [],
    currentNoteColor: window.currentNoteColor || 'color-1',
    selectedNoteKey: window.selectedNoteKey || null,
    // UI state
    showNotes: document.getElementById("show-notes")?.checked || false,
    displayMode: document.querySelector('input[name="display-mode"]:checked')?.value || 'notes',
    displayScope: document.querySelector('input[name="display-scope"]:checked')?.value || 'selected',
    noteNotation: document.querySelector('input[name="note-notation"]:checked')?.value || 'sharps',
    leftEnd: parseInt(document.getElementById("left-end")?.value) || 0,
    rightEnd: parseInt(document.getElementById("right-end")?.value) || 12,
    scrollPosition: document.getElementById("fretboard")?.scrollLeft || 0
  };

  // Convert to JSON string
  const jsonString = JSON.stringify(diagramData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  // Create download link
  const link = document.createElement("a");
  link.href = url;
  
  // Generate filename from title
  let baseName = diagramData.title;
  baseName = baseName.replace(/[\\\/:*?"<>|]/g, "");
  baseName = baseName.replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
  if (!baseName) baseName = "fretboard-diagram";
  baseName = baseName.slice(0, 200);
  
  link.download = `${baseName}.json`;
  link.click();
  
  // Clean up
  URL.revokeObjectURL(url);
});

// Load diagram from JSON
document.getElementById("load-diagram").addEventListener("click", () => {
  document.getElementById("load-file-input").click();
});

document.getElementById("load-file-input").addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const diagramData = JSON.parse(e.target.result);
      
      // Validate data structure
      if (!diagramData || typeof diagramData !== 'object') {
        alert('Invalid diagram file format');
        return;
      }

      // Restore state
      window.clickedNotes = diagramData.clickedNotes || [];
      window.filledNotes = diagramData.filledNotes || [];
      window.greyNotes = diagramData.greyNotes || [];
      window.currentNoteColor = diagramData.currentNoteColor || 'color-1';
      window.selectedNoteKey = diagramData.selectedNoteKey || null;

      // Restore instrument
      if (diagramData.instrument && document.getElementById("instrument-select")) {
        window.currentInstrument = diagramData.instrument;
        document.getElementById("instrument-select").value = diagramData.instrument;
      }

      // Restore title if available
      if (diagramData.title && document.getElementById("title")) {
        document.getElementById("title").value = diagramData.title;
      }

      // Restore UI state
      if (diagramData.showNotes !== undefined && document.getElementById("show-notes")) {
        document.getElementById("show-notes").checked = diagramData.showNotes;
        window.showNotes = diagramData.showNotes;
      }

      if (diagramData.displayMode) {
        const displayModeRadio = document.querySelector(`input[name="display-mode"][value="${diagramData.displayMode}"]`);
        if (displayModeRadio) {
          displayModeRadio.checked = true;
          window.showFunction = (diagramData.displayMode === 'function');
        }
      }

      if (diagramData.displayScope) {
        const displayScopeRadio = document.querySelector(`input[name="display-scope"][value="${diagramData.displayScope}"]`);
        if (displayScopeRadio) {
          displayScopeRadio.checked = true;
          window.showAll = (diagramData.displayScope === 'all');
        }
      }

      if (diagramData.noteNotation) {
        const noteNotationRadio = document.querySelector(`input[name="note-notation"][value="${diagramData.noteNotation}"]`);
        if (noteNotationRadio) {
          noteNotationRadio.checked = true;
          window.useFlats = (diagramData.noteNotation === 'flats');
        }
      }

      if (diagramData.leftEnd !== undefined && document.getElementById("left-end")) {
        document.getElementById("left-end").value = diagramData.leftEnd;
      }

      if (diagramData.rightEnd !== undefined && document.getElementById("right-end")) {
        document.getElementById("right-end").value = diagramData.rightEnd;
      }

      // Update the color palette selection
      const swatches = document.querySelectorAll('.color-palette .color-swatch');
      swatches.forEach(s => s.classList.remove('selected'));
      const selectedSwatch = document.querySelector(`.color-palette .color-swatch[data-color="${window.currentNoteColor}"]`);
      if (selectedSwatch) {
        selectedSwatch.classList.add('selected');
      }

      // Update the fretboard display
      updateFretboard();
      
      // Restore scroll position for piano keyboard
      if (diagramData.scrollPosition !== undefined) {
        const fretboard = document.getElementById("fretboard");
        if (fretboard) {
          fretboard.scrollLeft = diagramData.scrollPosition;
        }
      }
      
      console.log('Diagram loaded successfully');
    } catch (error) {
      console.error('Error loading diagram:', error);
      alert('Error loading diagram file. Please check the file format.');
    }
  };
  
  reader.readAsText(file);
  
  // Reset the input so the same file can be loaded again
  event.target.value = '';
});

</script>



</body>
</html>
